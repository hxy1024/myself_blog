-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: localhost    Database: blog_db
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `auth_group`
--

DROP TABLE IF EXISTS `auth_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(80) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group`
--

LOCK TABLES `auth_group` WRITE;
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group_permissions`
--

DROP TABLE IF EXISTS `auth_group_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_group_permissions_group_id_permission_id_0cd325b0_uniq` (`group_id`,`permission_id`),
  KEY `auth_group_permissio_permission_id_84c5c92e_fk_auth_perm` (`permission_id`),
  CONSTRAINT `auth_group_permissio_permission_id_84c5c92e_fk_auth_perm` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`),
  CONSTRAINT `auth_group_permissions_group_id_b120cbf9_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group_permissions`
--

LOCK TABLES `auth_group_permissions` WRITE;
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_permission`
--

DROP TABLE IF EXISTS `auth_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `content_type_id` int(11) NOT NULL,
  `codename` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `auth_permission_content_type_id_codename_01ab375a_uniq` (`content_type_id`,`codename`),
  CONSTRAINT `auth_permission_content_type_id_2f476e4b_fk_django_co` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_permission`
--

LOCK TABLES `auth_permission` WRITE;
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` VALUES (1,'Can add log entry',1,'add_logentry'),(2,'Can change log entry',1,'change_logentry'),(3,'Can delete log entry',1,'delete_logentry'),(4,'Can view log entry',1,'view_logentry'),(5,'Can add permission',2,'add_permission'),(6,'Can change permission',2,'change_permission'),(7,'Can delete permission',2,'delete_permission'),(8,'Can view permission',2,'view_permission'),(9,'Can add group',3,'add_group'),(10,'Can change group',3,'change_group'),(11,'Can delete group',3,'delete_group'),(12,'Can view group',3,'view_group'),(13,'Can add content type',4,'add_contenttype'),(14,'Can change content type',4,'change_contenttype'),(15,'Can delete content type',4,'delete_contenttype'),(16,'Can view content type',4,'view_contenttype'),(17,'Can add session',5,'add_session'),(18,'Can change session',5,'change_session'),(19,'Can delete session',5,'delete_session'),(20,'Can view session',5,'view_session'),(21,'Can add user',6,'add_account'),(22,'Can change user',6,'change_account'),(23,'Can delete user',6,'delete_account'),(24,'Can view user',6,'view_account'),(25,'Can add article',7,'add_article'),(26,'Can change article',7,'change_article'),(27,'Can delete article',7,'delete_article'),(28,'Can view article',7,'view_article'),(29,'Can add article up down',8,'add_articleupdown'),(30,'Can change article up down',8,'change_articleupdown'),(31,'Can delete article up down',8,'delete_articleupdown'),(32,'Can view article up down',8,'view_articleupdown'),(33,'Can add blog',9,'add_blog'),(34,'Can change blog',9,'change_blog'),(35,'Can delete blog',9,'delete_blog'),(36,'Can view blog',9,'view_blog'),(37,'Can add category',10,'add_category'),(38,'Can change category',10,'change_category'),(39,'Can delete category',10,'delete_category'),(40,'Can view category',10,'view_category'),(41,'Can add comment',11,'add_comment'),(42,'Can change comment',11,'change_comment'),(43,'Can delete comment',11,'delete_comment'),(44,'Can view comment',11,'view_comment'),(45,'Can add profile',12,'add_profile'),(46,'Can change profile',12,'change_profile'),(47,'Can delete profile',12,'delete_profile'),(48,'Can view profile',12,'view_profile');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_account`
--

DROP TABLE IF EXISTS `blog_account`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_account` (
  `password` varchar(128) NOT NULL,
  `last_login` datetime(6) DEFAULT NULL,
  `is_superuser` tinyint(1) NOT NULL,
  `username` varchar(150) NOT NULL,
  `first_name` varchar(30) NOT NULL,
  `last_name` varchar(150) NOT NULL,
  `email` varchar(254) NOT NULL,
  `is_staff` tinyint(1) NOT NULL,
  `is_active` tinyint(1) NOT NULL,
  `date_joined` datetime(6) NOT NULL,
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `telephone` varchar(11) NOT NULL,
  PRIMARY KEY (`nid`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_account`
--

LOCK TABLES `blog_account` WRITE;
/*!40000 ALTER TABLE `blog_account` DISABLE KEYS */;
INSERT INTO `blog_account` VALUES ('pbkdf2_sha256$120000$FcoKgsuy7XxK$RnEfy9DAquU5tH1+pxFH5zzTe0vDz3zcdOX0i7VSrzc=','2018-11-04 16:28:27.881477',0,'zlw10100','','','33@qq.com',0,1,'2018-11-04 13:04:58.824312',1,'18888888888'),('pbkdf2_sha256$120000$IHsSJJeUQqeS$t30KN4wM2RTZTSa1tux8RGxNXsPw1BQn3mUKRaDWhtI=','2018-11-04 16:42:39.134245',0,'zouliwei','','','2jk12@q.com',0,1,'2018-11-04 16:22:52.831303',2,'18888888888'),('pbkdf2_sha256$120000$YgkyzWAzOXtC$znyNi/vbqSjYuOkeLhyKYHA5psnQcL6spClMn/FKNBY=','2018-11-04 16:26:35.122298',0,'wj123','','','sadjl!@qq.com',0,1,'2018-11-04 16:25:57.189915',3,'18878787777'),('pbkdf2_sha256$120000$1dlvavYRCfYv$5GrLGzPlFedC0Z4ajRWgoU5qmwKoQFIHWWPq9CDjTcI=','2018-11-04 16:44:48.102166',0,'zhiqiang','','','jl@q.com',0,1,'2018-11-04 16:44:34.155044',4,'18876767789');
/*!40000 ALTER TABLE `blog_account` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_account_groups`
--

DROP TABLE IF EXISTS `blog_account_groups`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_account_groups` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `account_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_account_groups_account_id_group_id_1fdccc2e_uniq` (`account_id`,`group_id`),
  KEY `blog_account_groups_group_id_ab454803_fk_auth_group_id` (`group_id`),
  CONSTRAINT `blog_account_groups_account_id_3f05372e_fk_blog_account_nid` FOREIGN KEY (`account_id`) REFERENCES `blog_account` (`nid`),
  CONSTRAINT `blog_account_groups_group_id_ab454803_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_account_groups`
--

LOCK TABLES `blog_account_groups` WRITE;
/*!40000 ALTER TABLE `blog_account_groups` DISABLE KEYS */;
/*!40000 ALTER TABLE `blog_account_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_account_user_permissions`
--

DROP TABLE IF EXISTS `blog_account_user_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_account_user_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `account_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_account_user_permis_account_id_permission_id_84e45332_uniq` (`account_id`,`permission_id`),
  KEY `blog_account_user_pe_permission_id_aa46d90d_fk_auth_perm` (`permission_id`),
  CONSTRAINT `blog_account_user_pe_account_id_878ff8a1_fk_blog_acco` FOREIGN KEY (`account_id`) REFERENCES `blog_account` (`nid`),
  CONSTRAINT `blog_account_user_pe_permission_id_aa46d90d_fk_auth_perm` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_account_user_permissions`
--

LOCK TABLES `blog_account_user_permissions` WRITE;
/*!40000 ALTER TABLE `blog_account_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `blog_account_user_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_article`
--

DROP TABLE IF EXISTS `blog_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_article` (
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(32) NOT NULL,
  `create_time` datetime(6) NOT NULL,
  `last_modified` datetime(6) NOT NULL,
  `content` longtext NOT NULL,
  `comment_count` int(11) NOT NULL,
  `like_count` int(11) NOT NULL,
  `dislike_count` int(11) NOT NULL,
  `blog_id` int(11) NOT NULL,
  `category_id` int(11) NOT NULL,
  `img` varchar(100) DEFAULT NULL,
  `view_count` int(11) NOT NULL,
  PRIMARY KEY (`nid`),
  KEY `blog_article_blog_id_63b43504_fk_blog_blog_nid` (`blog_id`),
  KEY `blog_article_category_id_7e38f15e_fk_blog_category_nid` (`category_id`),
  CONSTRAINT `blog_article_blog_id_63b43504_fk_blog_blog_nid` FOREIGN KEY (`blog_id`) REFERENCES `blog_blog` (`nid`),
  CONSTRAINT `blog_article_category_id_7e38f15e_fk_blog_category_nid` FOREIGN KEY (`category_id`) REFERENCES `blog_category` (`nid`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_article`
--

LOCK TABLES `blog_article` WRITE;
/*!40000 ALTER TABLE `blog_article` DISABLE KEYS */;
INSERT INTO `blog_article` VALUES (1,'django框架--cookie/session','2018-11-04 13:13:28.259975','2018-11-04 13:13:28.259975','<div class=\"postBody\">\r\n	<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n		<p class=\"toc\">\r\n			目录\r\n		</p>\r\n		<ul>\r\n			<li>\r\n				<a href=\"#一http协议无状态问题\">一、http协议无状态问题</a> \r\n			</li>\r\n			<li>\r\n				<a href=\"#二会话跟踪技术--cookie\">二、会话跟踪技术--cookie</a> \r\n				<ul>\r\n					<li>\r\n						<a href=\"#对cookie的理解\">1、对cookie的理解</a> \r\n					</li>\r\n					<li>\r\n						<a href=\"#cookie的使用接口\">2、cookie的使用接口</a> \r\n					</li>\r\n					<li>\r\n						<a href=\"#cookie的属性\">3、cookie的属性</a> \r\n					</li>\r\n					<li>\r\n						<a href=\"#使用cookie的问题\">4、使用cookie的问题</a> \r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				<a href=\"#三会话跟踪技术--session\">三、会话跟踪技术--session</a> \r\n				<ul>\r\n					<li>\r\n						<a href=\"#对session的理解\">1、对session的理解</a> \r\n					</li>\r\n					<li>\r\n						<a href=\"#session的使用接口\">2、session的使用接口</a> \r\n					</li>\r\n					<li>\r\n						<a href=\"#session的属性\">3、session的属性</a> \r\n					</li>\r\n					<li>\r\n						<a href=\"#使用session的问题\">4、使用session的问题</a> \r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				<a href=\"#四总结\">四、总结</a> \r\n			</li>\r\n		</ul>\r\n		<h2 id=\"一http协议无状态问题\">\r\n			一、http协议无状态问题\r\n		</h2>\r\n		<p>\r\n			http协议没有提供多次请求之间的关联功能，协议的本意也并未考虑到多次请求之间的状态维持，每一次请求都被协议认为是一次性的。但在某些场景下，如一次登录多次访问，我们希望可以保存登录状态，协议并没有直接提供会话跟踪的支持，需要靠其他手段来帮助实现目标。\r\n		</p>\r\n		<h2 id=\"二会话跟踪技术--cookie\">\r\n			二、会话跟踪技术--cookie\r\n		</h2>\r\n		<h3 id=\"对cookie的理解\">\r\n			1、对cookie的理解\r\n		</h3>\r\n		<ul>\r\n			<li>\r\n				<p>\r\n					<strong>cookie是一个key-value的数据结构（类似python字典），用于保存需要维护状态的数据</strong>，cookie与session最大的区别是cookie的数据保存在客户端，而session把数据保存在服务端。\r\n				</p>\r\n			</li>\r\n			<li>\r\n				<p>\r\n					cookie一般由服务器设置，并可以存放在http的请求头和响应头中。\r\n				</p>\r\n			</li>\r\n			<li>\r\n				<p>\r\n					cookie由浏览器保存，浏览器已经实现了cookie的保存和发送，而服务器上对cookie的设置和接收则需要我们配置。\r\n				</p>\r\n			</li>\r\n			<li>\r\n				<p>\r\n					通过cookie，可以在多个会话之间共享一些必要的信息如登录状态数据、历史访问记录、个性化定制设置等，以实现会话跟踪，<strong>让用户感觉到网站可以\'记录\'自己的偏好，减少不必要的重复输入，从而提升用户体验。</strong> \r\n				</p>\r\n			</li>\r\n		</ul>\r\n		<h3 id=\"cookie的使用接口\">\r\n			2、cookie的使用接口\r\n		</h3>\r\n		<p>\r\n			django的服务端发送响应有三种方式：\r\n		</p>\r\n<pre><span class=\"hljs-bullet\">1. </span>return HttpResponse() <span class=\"hljs-bullet\">2. </span>return render() <span class=\"hljs-bullet\">3. </span>return redirect()</pre>\r\n		<p>\r\n			这三种方法实例化的结果都是HttpResponse类的实例，可以直接用于设置cookie。<br />\r\n在response对象上执行set_cookie(key,value,...)即可设置cookie, 其中特别注意cookie属性的设置。\r\n		</p>\r\n		<p>\r\n			<strong>cookie的设置</strong><br />\r\n服务器在响应对象上进行set_cookie操作，一旦设置完成，客户端后续的请求就可以根据cookie的属性规则携带cookie数据。\r\n		</p>\r\n<pre><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">set_cookie</span><span class=\"hljs-params\">(key, value=<span class=\"hljs-string\">\'\'</span>, max_age=None, expires=None, path=<span class=\"hljs-string\">\'/\'</span>,\r\n               domain=None, secure=False, httponly=False, samesite=None)</span></span></pre>\r\n		<p>\r\n			<strong>cookie的获取</strong><br />\r\n服务器在请求对象上通过request.COOKIES得到cookie字典数据，注意此处拿到的cookie数据从安全性来说是未被验证正确性的。\r\n		</p>\r\n<pre>@cached_property <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">COOKIES</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>)</span></span>:\r\n    raw_cookie = get_str_from_wsgi(<span class=\"hljs-keyword\">self</span>.environ, <span class=\"hljs-string\">\'HTTP_COOKIE\'</span>, <span class=\"hljs-string\">\'\'</span>) <span class=\"hljs-keyword\">return</span> parse_cookie(raw_cookie)</pre>\r\n		<p>\r\n			<em>注意1：cookie在set的时候可以设置它被发送的范围，每个cookie都有对应的domain+path的属性，这约束了cookie发送范围，只有当http的请求落在此范围中的url，才会携带此cookie。</em> \r\n		</p>\r\n		<p>\r\n			<em>注意2：一个cookie就是一个key-value项，不过它还携带有属性。一个cookies是一个字典，保存了很多cookie项，注意单个cookie项和整个cookies字典的关系。</em> \r\n		</p>\r\n		<h3 id=\"cookie的属性\">\r\n			3、cookie的属性\r\n		</h3>\r\n<pre><span class=\"hljs-attribute\">max_age</span>:\r\n失效延迟时间，单位是秒，设置成<span class=\"hljs-number\">15</span>秒意味着在设置完之后的<span class=\"hljs-number\">15</span>秒之内，此cookie有效，超时之后cookie失效，浏览器会删除失效的cookie。此参数默认是None，代表着直到浏览器关闭，即默认是会话cookie。\r\n注意：如果max_age是<span class=\"hljs-number\">0</span>，意味着让浏览器立刻删除此cookie，即此cookie即刻失效。 <span class=\"hljs-attribute\">expires</span>:\r\n指定失效日期,同样用于失效cookie，只不过是另一种时间指定方式。 <span class=\"hljs-attribute\">domain</span>:\r\n此cookie可以被使用的域名范围。 <span class=\"hljs-attribute\">path</span>:\r\n与domain配合着使用，默认是根路径<span class=\"hljs-string\">\'/\'</span>，意味着在当前domain范围下任何url都会携带此cookie。可以主动设置其他的路径以缩小发送的范围，从而约束某一个cookie项只应用于某些url。 <span class=\"hljs-attribute\">secure</span>:\r\n默认是False，一般配合https协议使用，在https协议下，只有secure属性是True的cookie才允许被发送。 <span class=\"hljs-attribute\">httponly</span>:\r\n默认是False，这意味着js也可以通过document.cookie来访问和设置此cookie，而如果设置为True，则代表只允许服务端来访问和设置此cookie。</pre>\r\n		<h3 id=\"使用cookie的问题\">\r\n			4、使用cookie的问题\r\n		</h3>\r\n		<p>\r\n			<strong>cookie的安全性问题</strong><br />\r\n服务器是根据客户端发送过来的cookie进行状态判断，这种保存在客户端的cookie数据非常容易修改和伪装，服务器基本无法知晓cookie的正确性，也就不能100%信任cookie的数据。<br />\r\n此外，cookie很容易被盗取，如果客户端cookie里面包含私密数据的话，就更不安全了。\r\n		</p>\r\n		<p>\r\n			<strong>cookie的覆盖问题</strong><br />\r\n在服务端上设置的新的cookie会让客户端更新本地cookie。\r\n		</p>\r\n		<p>\r\n			<strong>cookie的合理性问题</strong><br />\r\n什么样的数据适合放到cookie中?<br />\r\ncookie中的数据是每次交互都要被传输的，所以我认为：\r\n		</p>\r\n		<ul>\r\n			<li>\r\n				应该是常用的数据，如果不常用只会浪费带宽减少效率，最好是多次交互中都要使用或者修改\r\n			</li>\r\n			<li>\r\n				应该是小数据量\r\n			</li>\r\n			<li>\r\n				不应该是非常私密的数据，否则：要么在客户端上容易被盗取，要么在传输中容易被截取\r\n			</li>\r\n		</ul>\r\n		<p>\r\n			<em>所以cookie特别适合发送sessionid，它能满足上述所有条件。</em> \r\n		</p>\r\n		<p>\r\n			<strong>cookie的存储问题</strong><br />\r\ncookie是客户端临时存储，按规定单个cookie文件存储量最大是4kb，每个域下的cookie文件不能超过20个，不应该将cookie作为存储功能的滥用，要使用客户端存储功能应该启用localstorage。\r\n		</p>\r\n		<p>\r\n			<strong>cookie的访问限制问题</strong><br />\r\njs的document.cookie可以获取cookie数据，将会在控制台输出一个字符串格式的key-value数据,如果此cookie的属性是httponly=true就不能通过此方法获取。\r\n		</p>\r\n		<h2 id=\"三会话跟踪技术--session\">\r\n			三、会话跟踪技术--session\r\n		</h2>\r\n		<h3 id=\"对session的理解\">\r\n			1、对session的理解\r\n		</h3>\r\n		<p>\r\n			session把数据存放在服务器上，并使用一个标签session-key唯一标记此数据。session-key作为cookie发送给客户端，即客户端只保存session-key，然后通过cookie发送给服务端，以表明身份，所以session比cookie安全。\r\n		</p>\r\n		<p>\r\n			每一次请求到达服务器的时候，服务器获取cookie中保存的session-key，并在数据库django-session表中寻找对应的session-data，进一步处理业务逻辑。\r\n		</p>\r\n		<p>\r\n			session的使用有如下优点：<br />\r\n1、数据保存在服务端，客户端仅保存一个senssionid<br />\r\n2、sessionid数据量很小，适合每次发送<br />\r\n3、安全性，sessionid是一个随机字符串，不携带任何私密数据\r\n		</p>\r\n		<h3 id=\"session的使用接口\">\r\n			2、session的使用接口\r\n		</h3>\r\n		<p>\r\n			<strong>session的设置</strong> \r\n		</p>\r\n		<p>\r\n			django实现了session，帮我们完成了很多操作，且提供使用的接口非常简单：\r\n		</p>\r\n<pre>request.session[<span class=\"hljs-string\">\'name\'</span>] = <span class=\"hljs-string\">\'xxx\'</span></pre>\r\n		<p>\r\n			设置session的时候会执行如下三个操作：\r\n		</p>\r\n<pre><span class=\"hljs-number\">1</span>、创建一个随机字符串作为sessionid <span class=\"hljs-number\">2</span>、把sessionid作为session-<span class=\"hljs-keyword\">key</span>，以及一个session_data字典加入到django-session表中 <span class=\"hljs-number\">3</span>、<span class=\"hljs-keyword\">set</span>-cookie,把sessionid发送给客户端</pre>\r\n		<p>\r\n			<em>注意1：从底层源码来看，session_data其实就是一个字典{}，然后通过orm存到django_session表中(应该有dict--&gt;str的序列化和加密操作)</em> \r\n		</p>\r\n		<p>\r\n			<em>注意2：如果发现客户端的cookie中含有seesionid说明不是第一次登录，将会使用此sessionid并更新此sessionid对应的session_data数据</em> \r\n		</p>\r\n		<p>\r\n			<em>注意3：如果有两个用户在同一台电脑的同一个浏览器上，访问同一个url，因为sessionid是作为cookie存在，所以两个人会使用同一个sessionid。</em><br />\r\n<em>而对于服务器而言，只认sessionid不认人，使用同一个sessionid的操作会覆盖之前的数据以导致在服务端上的session_data数据会相互覆盖，这样的结果是数据紊乱(尤其当两人的数据项目数量不一致时更严重)</em> \r\n		</p>\r\n		<p>\r\n			<strong>session的读取</strong> \r\n		</p>\r\n		<p>\r\n			读取session的接口同样很简单：\r\n		</p>\r\n<pre><span class=\"hljs-attr\">name</span> = request.session[<span class=\"hljs-string\">\'name\'</span>]</pre>\r\n		<p>\r\n			读取的时候会执行如下三个操作：\r\n		</p>\r\n<pre><span class=\"hljs-number\">1</span>、获取request.<span class=\"hljs-type\">COOKIES</span>中的sessionid <span class=\"hljs-number\">2</span>、拿着sessionid作为session_key到数据库的django-session表中查找对应的session-<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>,底层就是执行orm的objects.filter(<span class=\"hljs-title\">session_key</span>=<span class=\"hljs-title\">sessionid</span>)</span> <span class=\"hljs-number\">3</span>、获取session-<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>中的数据并进一步处理</span></pre>\r\n		<p>\r\n			<strong>session的删除</strong> \r\n		</p>\r\n		<p>\r\n			删除session的接口：\r\n		</p>\r\n<pre>1、<span class=\"hljs-selector-tag\">del</span> <span class=\"hljs-selector-tag\">request</span><span class=\"hljs-selector-class\">.session</span><span class=\"hljs-selector-attr\">[xxx]</span> # 删除一个会话数据属性\r\n2、<span class=\"hljs-selector-tag\">request</span><span class=\"hljs-selector-class\">.session</span><span class=\"hljs-selector-class\">.flush</span>()    # 删除所有会话数据</pre>\r\n		<p>\r\n			清空会话信息时会执行如下操作：\r\n		</p>\r\n<pre><span class=\"hljs-number\">1</span>、删除django-session表中的session-<span class=\"hljs-keyword\">key</span>=sessionid的记录，底层操作就是执行orm的objects.filter(session_key=sessionid).<span class=\"hljs-keyword\">delete</span>() <span class=\"hljs-number\">2</span>、删除response中的cookie里的sessionid记录</pre>\r\n		<p>\r\n			<em>注意1：服务器把sessionid作为cookie的数据发给客户端保存，一般是会话cookie即不关闭浏览器程序就可以一直保持会话跟踪。但一旦客户端关闭了浏览器，则此sessionid便不再有效。但django颁发的cookie默认有效时间是2周，所以cookie会被保存到客户端硬盘上，即使关闭了浏览器也继续保存。</em> \r\n		</p>\r\n		<p>\r\n			<em>注意2：因为服务器无法获知客户端浏览器将会在什么时候关闭，更无法获知浏览器什么时候会执行清空cookie的操作。客户端一般只有在logout的时候才会主动告知删除session，其他情况下浏览器不会主动告知，所以服务器的session不能无限保存，被迫要设置失效时间（不然存储空间浪费），在一定时间内如果还没有用户重新访问此session，便被服务端认为此用户已失效，进而可以删除session数据。</em> \r\n		</p>\r\n		<h3 id=\"session的属性\">\r\n			3、session的属性\r\n		</h3>\r\n		<p>\r\n			settings中还可以配置全局的session属性：\r\n		</p>\r\n<pre><span class=\"hljs-comment\"># settings.py文件</span> SESSION_ENGINE = <span class=\"hljs-string\">\'django.contrib.sessions.backends.db\'</span> <span class=\"hljs-comment\"># 引擎（默认）</span> SESSION_COOKIE_NAME ＝ <span class=\"hljs-string\">\"sessionid\"</span> <span class=\"hljs-comment\"># Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）</span> SESSION_COOKIE_PATH ＝ <span class=\"hljs-string\">\"/\"</span> <span class=\"hljs-comment\"># Session的cookie保存的路径（默认）</span> SESSION_COOKIE_DOMAIN = <span class=\"hljs-keyword\">None</span> <span class=\"hljs-comment\"># Session的cookie保存的域名（默认）</span> SESSION_COOKIE_SECURE = <span class=\"hljs-keyword\">False</span> <span class=\"hljs-comment\"># 是否Https传输cookie（默认）</span> SESSION_COOKIE_HTTPONLY = <span class=\"hljs-keyword\">True</span> <span class=\"hljs-comment\"># 是否Session的cookie只支持http传输（默认）</span> SESSION_COOKIE_AGE = <span class=\"hljs-number\">1209600</span> <span class=\"hljs-comment\"># Session的cookie失效日期（2周）（默认）</span> SESSION_EXPIRE_AT_BROWSER_CLOSE = <span class=\"hljs-keyword\">False</span> <span class=\"hljs-comment\"># 是否关闭浏览器使得Session过期（默认）</span> SESSION_SAVE_EVERY_REQUEST = <span class=\"hljs-keyword\">False</span> <span class=\"hljs-comment\"># 是否每次请求都保存Session，默认修改之后才保存（默认）</span></pre>\r\n		<h3 id=\"使用session的问题\">\r\n			4、使用session的问题\r\n		</h3>\r\n		<p>\r\n			1、session的正常工作依赖于cookie的启用，如果客户端禁用cookie功能，该如何保证session正常工作？---重写URL\r\n		</p>\r\n		<p>\r\n			2、同一台电脑同一个浏览器，访问同一个url，保存着同一个sessionid，如何处理多用户使用同一sessionid登录而导致的数据紊乱问题？---使用用户认证组件，使用账户密码来区别用户\r\n		</p>\r\n		<h2 id=\"四总结\">\r\n			四、总结\r\n		</h2>\r\n		<p>\r\n			1、cookie和session都是为了解决http协议自身并不支持状态维持的缺点。<br />\r\n2、会话跟踪的目的是为了让多次请求之间可以共享数据，以提供更好的用户体验。<br />\r\n3、cookie和session都需要保存<strong>状态维持数据</strong>，只不过cookie是保存在客户端，session是保存在服务端。<br />\r\n4、分析和研究两者的技术相同点和区别有助于加深对会话跟踪的理解和使用。\r\n		</p>\r\n	</div>\r\n	<div id=\"MySignature\">\r\n	</div>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div id=\"blog_post_info_block\">\r\n		<br />\r\n	</div>\r\n</div>',14,2,0,1,2,'article_imgs/1.jpg',41),(3,'django框架--中间件系统','2018-11-04 16:06:10.680470','2018-11-04 16:06:10.680470','<div class=\"post\">\r\n	<h1 class=\"postTitle\">\r\n		<a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"https://www.cnblogs.com/zzzlw/p/9776395.html\">django框架--中间件系统</a> \r\n	</h1>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div class=\"postBody\">\r\n		<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n			<p class=\"toc\">\r\n				目录\r\n			</p>\r\n			<ul>\r\n				<li>\r\n					<a href=\"#零参考\">零、参考</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#一中间件的基本理解\">一、中间件的基本理解</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#二中间件的系统定位\">二、中间件的系统定位</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#三中间件的配置\">三、中间件的配置</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#四中间件的执行流程\">四、中间件的执行流程</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#五中间件与装饰器之间的思考\">五、中间件与装饰器之间的思考</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#六中间件的应用场景\">六、中间件的应用场景</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#七内置中间件\">七、内置中间件</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#八总结\">八、总结</a> \r\n				</li>\r\n			</ul>\r\n			<h2 id=\"零参考\">\r\n				零、参考\r\n			</h2>\r\n			<p>\r\n				https://www.jb51.net/article/136422.htm<br />\r\nhttps://www.jb51.net/article/143832.htm<br />\r\nhttps://www.jb51.net/article/69953.htm\r\n			</p>\r\n			<h2 id=\"一中间件的基本理解\">\r\n				一、中间件的基本理解\r\n			</h2>\r\n			<p>\r\n				我对django中间件的理解：<strong>以组件化的形式，为大量的请求或响应提供批量化处理的接口，封装着可插拔式的独立附加功能逻辑，与基本web业务逻辑功能解耦，通过hook函数能更细致的处理请求或响应过程。</strong> \r\n			</p>\r\n			<p>\r\n				django的中间件有如下特点：<br />\r\n1、每个中间件由一个类来表示<br />\r\n2、中间件的逻辑必须写在特定的接口中，这些接口被称为hook函数<br />\r\n3、中间件的执行有顺序依赖<br />\r\n4、hook函数的执行有规定顺序<br />\r\n5、中间件的启用会影响所有的请求/响应<br />\r\n6、中间件是可插拔式的，这意味着可以不启用任何中间件<br />\r\n7、中间件应该仅作为数据过滤器的角色对数据过滤、转换、清洗，对数据的业务处理应该放在视图系统中<br />\r\n8、如第7点，中间件应该作为额外功能模块介入请求/响应流程，与普通业务处理模块(视图系统)解耦\r\n			</p>\r\n			<h2 id=\"二中间件的系统定位\">\r\n				二、中间件的系统定位\r\n			</h2>\r\n			<p>\r\n				<strong>中间件在django框架中的定位图</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012102613988-1476135912.jpg\" /> \r\n			</p>\r\n			<h2 id=\"三中间件的配置\">\r\n				三、中间件的配置\r\n			</h2>\r\n			<p>\r\n				<strong>配置中间件类</strong> \r\n			</p>\r\n<pre><span class=\"hljs-keyword\">from</span> django.utils.deprecation <span class=\"hljs-keyword\">import</span> MiddlewareMixin <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyMiddleware</span><span class=\"hljs-params\">(MiddlewareMixin)</span>:</span> <span class=\"hljs-string\">\'\'\'\r\n    自定义类名，继承内置的中间件混合类。\r\n    hook函数有固定的接口，自定义逻辑处理代码\r\n    \'\'\'</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_request</span><span class=\"hljs-params\">(self, request)</span>:</span> <span class=\"hljs-keyword\">pass</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_view</span><span class=\"hljs-params\">(self, request, callback, callback_args, callback_kwargs)</span>:</span> <span class=\"hljs-keyword\">pass</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_exception</span><span class=\"hljs-params\">(self, request, exception)</span>:</span> <span class=\"hljs-keyword\">pass</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_template_response</span><span class=\"hljs-params\">(self, request, response)</span>:</span> <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_response</span><span class=\"hljs-params\">(self, request, response)</span>:</span> <span class=\"hljs-keyword\">return</span> response</pre>\r\n			<p>\r\n				<strong>编写中间件hook函数逻辑</strong> \r\n			</p>\r\n			<p>\r\n				<strong>1、process_request(self, request)</strong><br />\r\n参数request是HttpRequest对象，此hook函数将会在路由分发前执行，有两类返回值：\r\n			</p>\r\n<pre><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">None</span> <span class=\"hljs-comment\"># 请求流程将会继续按照原计划执行，这应该是默认设置</span> <span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">return</span> HttpResponse <span class=\"hljs-comment\"># 请求将会跳转到当前中间件的process_response函数处理并进入响应流程</span> 注意：虽然<span class=\"hljs-keyword\">return</span>一个非<span class=\"hljs-keyword\">None</span>且非HttpResonse的值也会使得流程跳转到响应流程，不过并不建议这么做，因为每一个process_response函数都期望接收到一个HttpResponse对象以便做进一步的处理，而不是收到一个奇怪的字符串或者数字。\r\n\r\n注意：进入响应流程的入口是当前中间件的process_response</pre>\r\n			<p>\r\n				<strong>2、process_view(self, request, callback, callback_args, callback_kwargs)</strong><br />\r\n请求流程完成路由分发后，在执行视图函数前将会执行此hook函数。此函数的callback是对路由分发确定的视图函数的引用，callback_args,callback_kwargs是传递给视图函数的参数，有两类返回值：\r\n			</p>\r\n<pre><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">None</span> <span class=\"hljs-comment\"># 请求流程将会按照原计划继续，这应该是默认设置</span> <span class=\"hljs-number\">2.</span><span class=\"hljs-keyword\">return</span> HttpResponse <span class=\"hljs-comment\"># 请求将会跳转到最后一个中间件的process_response函数处理并进入响应流程</span> 注意：进入响应流程的入口是最后一个中间件的process_response</pre>\r\n			<p>\r\n				<strong>3、process_template_response</strong><br />\r\n在view视图函数中使用render渲染一个模版对象完成之后被调用，它必须返回一个render方法执行后的response对象。\r\n			</p>\r\n			<p>\r\n				<strong>4、process_exception(self, request, exception)</strong><br />\r\n当视图函数执行出错的时候，会把错误抛给此hook函数，有两类返回值：\r\n			</p>\r\n<pre><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">None</span> <span class=\"hljs-comment\"># 将会把错误对象exception提交给前一个中间件的process_exception处理</span> <span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">return</span> HttpResponse <span class=\"hljs-comment\"># 将会跳转到最后一个中间件的process_response函数处理并进入响应流程</span> 注意：不应该<span class=\"hljs-keyword\">return</span> exception\r\n\r\n注意：进入响应流程的入口是最后一个中间件的process_response</pre>\r\n			<p>\r\n				<strong>5、process_response（self, request, response)</strong><br />\r\n此hook函数将在响应流程中执行，函数必须返回HttpResponse对象\r\n			</p>\r\n<pre><span class=\"hljs-keyword\">return</span> HttpResponse <span class=\"hljs-comment\"># 把响应对象交给前一个中间件的process_response函数处理，如果已经是第一个中间件，将会交给wsgi服务器处理并发送给用户浏览器。</span> 注意：必须返回HttpResponse对象</pre>\r\n			<p>\r\n				<strong>启用中间件</strong> \r\n			</p>\r\n			<p>\r\n				在项目settings文件中添加对中间件类的引用以启动中间件\r\n			</p>\r\n<pre><span class=\"hljs-attribute\">MIDDLEWARE</span> = [ <span class=\"hljs-string\">\'django.middleware.security.SecurityMiddleware\'</span>, <span class=\"hljs-string\">\'django.contrib.sessions.middleware.SessionMiddleware\'</span>, <span class=\"hljs-string\">\'django.middleware.common.CommonMiddleware\'</span>, <span class=\"hljs-string\">\'django.middleware.csrf.CsrfViewMiddleware\'</span>, <span class=\"hljs-string\">\'django.contrib.auth.middleware.AuthenticationMiddleware\'</span>, <span class=\"hljs-string\">\'django.contrib.messages.middleware.MessageMiddleware\'</span>, <span class=\"hljs-string\">\'django.middleware.clickjacking.XFrameOptionsMiddleware\'</span>, <span class=\"hljs-string\">\'app01.my_middlewares.MyMiddleware\'</span>, <span class=\"hljs-comment\"># 添加对自定义中间件类的引用以启动</span> ]</pre>\r\n			<h2 id=\"四中间件的执行流程\">\r\n				四、中间件的执行流程\r\n			</h2>\r\n			<p>\r\n				<strong>中间件及hook函数执行流程(省略process_template_response)</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012102710955-513234702.jpg\" /> \r\n			</p>\r\n			<h2 id=\"五中间件与装饰器之间的思考\">\r\n				五、中间件与装饰器之间的思考\r\n			</h2>\r\n			<p>\r\n				中间件的功能划分遵循原则：<strong>视图函数仅完成本应完成的工作，额外的功能通过中间件来单独提供</strong>。<br />\r\n中间件是可插拔式即意味着中间件的启用和禁用均不会影响视图函数的原始工作，这非常像之前学习过的python装饰器。python装饰器实现了设计模式中的装饰模式，装饰器的目的是：在保持原有函数功能的基础之上，新增额外的功能，且新增的功能应该与原函数功能解耦，装饰器也可以有选择的增加或者移除。通过自己的研究和网上各大神的博客学习中发现，django的中间件其实也是一种装饰模式，而且可以和python的装饰器用法高度适配，我用如下两张图来对django中间件和装饰器进行了转换。\r\n			</p>\r\n			<p>\r\n				<strong>图一、django中间件到装饰器的转换</strong> \r\n			</p>\r\n			<p>\r\n				<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012123245489-424840949.jpg\" /> \r\n			</p>\r\n			<p>\r\n				<strong>图二、django中间件到装饰器的转换</strong> \r\n			</p>\r\n			<p>\r\n				<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012123254648-253698089.jpg\" /> \r\n			</p>\r\n			<p>\r\n				<strong>python多重装饰器</strong><br />\r\n虽然还没研究过django中间件的源代码，不过我想先尝试着使用python的装饰器来模拟中间件的效果。<br />\r\n首先，要理解装饰器的核心知识：<strong>利用闭包特性来保存内层函数的执行上下文</strong>。正因为闭包的存在，内层函数的执行上下文(执行环境)即使在外层函数结束后依然可以被保存，这就意味着在外层函数结束后，依然可以正确的执行内层函数。 <em>（ps：如果不使用闭包，外层函数结束后，该函数中的所有变量都会被销毁）</em> \r\n			</p>\r\n			<p>\r\n				其次，<strong>装饰器可以迭代使用</strong>。\r\n			</p>\r\n			<blockquote>\r\n				<p>\r\n					迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。<br />\r\n---百度百科\r\n				</p>\r\n			</blockquote>\r\n			<p>\r\n				就像这样：\r\n			</p>\r\n<pre><span class=\"hljs-variable\">@IPFilter</span> <span class=\"hljs-variable\">@UserAuth</span> <span class=\"hljs-variable\">@DataTransform</span> <span class=\"hljs-variable\">@TrafficLog</span> def index(request):\r\n    # somecode...\r\n    return response</pre>\r\n			<p>\r\n				<strong>利用装饰器函数模拟中间件效果</strong> \r\n			</p>\r\n			<p>\r\n				现在我们通过一个多重函数装饰器简单的模拟一下中间件的效果，需求如下：\r\n			</p>\r\n			<p>\r\n				<em>有一个ip黑名单列表，列表中的ip不能访问页面。此外，有三个函数需要定义：</em><br />\r\n<em>一个简单的show_page函数，将会模拟用户访问某一个页面，并返回简单的内容(当前用户的ip)。</em><br />\r\n<em>一个filter_ip装饰器，过滤恶意ip，如果用户ip在黑名单中就无法正常访问页面。</em><br />\r\n<em>一个traffic_log装饰器，对正常访问的流量进行统计。</em><br />\r\n<em>基础需求：通过自定义一个request对象模拟用户浏览器发出的http请求对象，request直接执行show_page视图函数以得到期望访问的http页面。</em><br />\r\n<em>额外需求：通过添加以上两个装饰器来增加ip过滤和流量统计的功能。</em> \r\n			</p>\r\n			<p>\r\n				代码定义如下：\r\n			</p>\r\n<pre><span class=\"hljs-comment\"># 黑名单的定义</span> black_ip_list = [<span class=\"hljs-string\">\'10.1.1.1\'</span>, <span class=\"hljs-string\">\'172.16.1.1\'</span>, <span class=\"hljs-string\">\'192.168.1.1\'</span>] <span class=\"hljs-comment\"># 这里简单的使用全局变量来表示统计流量</span> traffic_count = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\"># request对象的定义</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Request</span><span class=\"hljs-params\">(object)</span>:</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self, source_ip)</span>:</span> self.source_ip = source_ip <span class=\"hljs-comment\"># filter_ip过滤器函数的定义</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">filter_ip</span><span class=\"hljs-params\">(func)</span>:</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">inner</span><span class=\"hljs-params\">(request)</span>:</span> source_ip = request.source_ip <span class=\"hljs-keyword\">if</span> source_ip <span class=\"hljs-keyword\">in</span> black_ip_list:\r\n            response = <span class=\"hljs-string\">\'你的ip在黑名单中\'</span> <span class=\"hljs-keyword\">else</span>:\r\n            response = func(request) <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-keyword\">return</span> inner <span class=\"hljs-comment\"># traffic_log流量统计函数的定义</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">traffic_log</span><span class=\"hljs-params\">(func)</span>:</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">inner</span><span class=\"hljs-params\">(request)</span>:</span> <span class=\"hljs-keyword\">global</span> traffic_count  \r\n        traffic_count += <span class=\"hljs-number\">1</span> print(<span class=\"hljs-string\">\'当前页面被有效请求的次数是:\'</span>, traffic_count)\r\n\r\n        response = func(request) <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-keyword\">return</span> inner <span class=\"hljs-comment\"># show_page视图函数的定义</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">show_page</span><span class=\"hljs-params\">(request)</span>:</span> source_ip = request.source_ip\r\n    response = <span class=\"hljs-string\">\'模拟的目标页面内容,此用户的ip是--&gt;\'</span> + source_ip <span class=\"hljs-keyword\">return</span> response</pre>\r\n			<p>\r\n				<strong>结果1，实现最基本的用户访问</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143638992-1971009650.png\" /> \r\n			</p>\r\n			<p>\r\n				<strong>结果2，实现ip黑名单过滤</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143645242-239899405.png\" /> \r\n			</p>\r\n			<p>\r\n				<strong>结果3，实现有效流量统计</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143650379-315852718.png\" /> \r\n			</p>\r\n			<p>\r\n				<strong>结果4，实现ip黑名单过滤+有效流量统计(特别注意顺序依赖)</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012143655558-1670987213.png\" /> \r\n			</p>\r\n			<p>\r\n				<strong>利用装饰器类模拟中间件效果</strong><br />\r\n虽然简单的模拟出了中间件的可插拔、功能解耦、批量请求处理等功能，但还做的不够好，我们可以基于上面的代码，再做一些必要的封装，代码如下：\r\n			</p>\r\n<pre><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrafficLogMiddleware</span>(<span class=\"hljs-title\">object</span>):</span> traffic_count = <span class=\"hljs-number\">0</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, func)</span></span>: <span class=\"hljs-keyword\">self</span>.func = func <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__call__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request)</span></span>: <span class=\"hljs-keyword\">self</span>.traffic_count += <span class=\"hljs-number\">1</span> print(<span class=\"hljs-string\">\'当前页面被有效请求的次数是:\'</span>, <span class=\"hljs-keyword\">self</span>.traffic_count)\r\n\r\n        response = <span class=\"hljs-keyword\">self</span>.func(request) <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FilterIPMiddleware</span>(<span class=\"hljs-title\">object</span>):</span> black_ip_list = [<span class=\"hljs-string\">\'10.1.1.1\'</span>, <span class=\"hljs-string\">\'172.16.1.1\'</span>, <span class=\"hljs-string\">\'192.168.1.1\'</span>] <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, func)</span></span>: <span class=\"hljs-keyword\">self</span>.func = func <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__call__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request)</span></span>:\r\n        source_ip = request.source_ip <span class=\"hljs-keyword\">if</span> source_ip <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-symbol\">black_ip_list:</span> response = <span class=\"hljs-string\">\'你的ip在黑名单中\'</span> <span class=\"hljs-symbol\">else:</span> response = <span class=\"hljs-keyword\">self</span>.func(request) <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Request</span>(<span class=\"hljs-title\">object</span>):</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, source_ip)</span></span>: <span class=\"hljs-keyword\">self</span>.source_ip = source_ip\r\n\r\n\r\n@FilterIPMiddleware\r\n@TrafficLogMiddleware <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">show_page</span><span class=\"hljs-params\">(request)</span></span>:\r\n    source_ip = request.source_ip\r\n    response = <span class=\"hljs-string\">\'模拟的目标页面内容,此用户的ip是--&gt;\'</span> + source_ip <span class=\"hljs-keyword\">return</span> response</pre>\r\n			<p>\r\n				<strong>感觉不像django的中间件接口？可以这样写：</strong> \r\n			</p>\r\n<pre><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Middleware</span>(<span class=\"hljs-title\">object</span>):</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, func)</span></span>: <span class=\"hljs-keyword\">self</span>.func = func <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__call__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request)</span></span>:\r\n        response = <span class=\"hljs-keyword\">self</span>.process_request(request) <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-symbol\">response:</span> response = <span class=\"hljs-keyword\">self</span>.func(request)\r\n        response = <span class=\"hljs-keyword\">self</span>.process_response(request, response) <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_request</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request)</span></span>:\r\n        pass <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_response</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request, response)</span></span>: <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrafficLogMiddleware</span>(<span class=\"hljs-title\">Middleware</span>):</span> traffic_count = <span class=\"hljs-number\">0</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_request</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request)</span></span>: <span class=\"hljs-keyword\">self</span>.traffic_count += <span class=\"hljs-number\">1</span> print(<span class=\"hljs-string\">\'当前页面被有效请求的次数是:\'</span>, <span class=\"hljs-keyword\">self</span>.traffic_count) <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_response</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request, response)</span></span>: <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FilterIPMiddleware</span>(<span class=\"hljs-title\">Middleware</span>):</span> black_ip_list = [<span class=\"hljs-string\">\'10.1.1.1\'</span>, <span class=\"hljs-string\">\'172.16.1.1\'</span>, <span class=\"hljs-string\">\'192.168.1.1\'</span>] <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_request</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request)</span></span>:\r\n        source_ip = request.source_ip <span class=\"hljs-keyword\">if</span> source_ip <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-symbol\">black_ip_list:</span> response = <span class=\"hljs-string\">\'你的ip在黑名单中\'</span> <span class=\"hljs-symbol\">else:</span> response = None <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">process_response</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, request, response)</span></span>: <span class=\"hljs-keyword\">return</span> response <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Request</span>(<span class=\"hljs-title\">object</span>):</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, source_ip)</span></span>: <span class=\"hljs-keyword\">self</span>.source_ip = source_ip\r\n\r\n\r\n@FilterIPMiddleware\r\n@TrafficLogMiddleware <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">show_page</span><span class=\"hljs-params\">(request)</span></span>:\r\n    source_ip = request.source_ip\r\n    response = <span class=\"hljs-string\">\'模拟的目标页面内容,此用户的ip是--&gt;\'</span> + source_ip <span class=\"hljs-keyword\">return</span> response</pre>\r\n			<p>\r\n				<strong>执行结果如下：</strong><br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181012153132932-1547947261.png\" /> \r\n			</p>\r\n			<h2 id=\"六中间件的应用场景\">\r\n				六、中间件的应用场景\r\n			</h2>\r\n			<p>\r\n				中间件的启用会影响所有的请求/响应---&gt;适用于大量请求/响应的批量化处理场景<br />\r\n中间件相互之间功能解耦，顺序依赖---&gt;适合可插拔式的业务场景<br />\r\n中间件可以介入请求/响应流程---&gt;适用于需要更加细致化处理请求/响应流程的业务场景<br />\r\n1、流量统计<br />\r\n2、恶意ip过滤<br />\r\n3、用户区分<br />\r\n4、缓存CDN<br />\r\n5、URL过滤<br />\r\n6、数据预处理<br />\r\n......\r\n			</p>\r\n			<h2 id=\"七内置中间件\">\r\n				七、内置中间件\r\n			</h2>\r\n			<p>\r\n				django框架内置了7个中间件，用于提供基本的http请求和响应处理，内置中间件的基本学习可以参考：<br />\r\nhttps://www.jb51.net/article/69953.htm\r\n			</p>\r\n			<h2 id=\"八总结\">\r\n				八、总结\r\n			</h2>\r\n			<p>\r\n				1、装饰器和中间件都实现了装饰模式，此模式的目的是为了在不修改原有模块的条件下新增功能代码，并可以提供可插拔的效果，同时新增代码和原有代码功能上解耦。<br />\r\n2、类比学习很重要，可以同时提升对两个同类知识的理解。<br />\r\n3、中间件的角色应该是数据清洗/过滤/转换器，不应该在中间件上处理业务逻辑，而只是处理数据约束，具体的业务逻辑应该放置在视图函数中，这也是它的本职工作。<br />\r\n4、不要滥用中间件，过多的中间件会增加请求/响应流程的环节数，发生错误的时候提升排错难度。中间件的使用应该依赖业务场景，在最合适的地方使用最合适的技术，才能发挥最高的效率。\r\n			</p>\r\n		</div>\r\n		<div id=\"MySignature\">\r\n		</div>\r\n		<div class=\"clear\">\r\n		</div>\r\n		<p>\r\n			<br />\r\n		</p>\r\n		<p>\r\n			<br />\r\n		</p>\r\n		<p>\r\n			<br />\r\n		</p>\r\n	</div>\r\n</div>',1,0,0,1,2,'article_imgs/3.jpg',4),(4,'django框架--底层架构','2018-11-04 16:07:03.249833','2018-11-04 16:07:03.249833','<div class=\"post\">\r\n	<h1 class=\"postTitle\">\r\n		<a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"https://www.cnblogs.com/zzzlw/p/9747872.html\">django框架--底层架构</a> \r\n	</h1>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div class=\"postBody\">\r\n		<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n			<p class=\"toc\">\r\n				目录\r\n			</p>\r\n			<ul>\r\n				<li>\r\n					<a href=\"#零参考\">零、参考</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#一对于web服务的理解\">一、对于web服务的理解</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#二对于wsgi协议的理解\">二、对于wsgi协议的理解</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#三自定义一个简单的基于wsgi协议的web框架\">三、自定义一个简单的基于wsgi协议的web框架</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#四django中的server实现\">四、django中的server实现</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#五django中的application实现\">五、django中的application实现</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#六django的底层调用链\">六、django的底层调用链</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#七总结\">七、总结</a> \r\n				</li>\r\n			</ul>\r\n			<h2 id=\"零参考\">\r\n				零、参考\r\n			</h2>\r\n			<p>\r\n				<a href=\"https://www.jianshu.com/p/679dee0a4193\" class=\"uri\">https://www.jianshu.com/p/679dee0a4193</a><br />\r\n<a href=\"https://www.letiantian.me/2015-09-10-understand-python-wsgi/\" class=\"uri\">https://www.letiantian.me/2015-09-10-understand-python-wsgi/</a> \r\n			</p>\r\n			<h2 id=\"一对于web服务的理解\">\r\n				一、对于web服务的理解\r\n			</h2>\r\n			<p>\r\n				web服务应该至少包含两个模块：web服务器和web应用程序，两个模块在功能和代码上解耦。<br />\r\nweb服务器负责处理socket调用、http数据解析和封装等底层操作。<br />\r\nweb应用程序负责业务处理、数据增删改查、页面渲染/生成等高层操作。<br />\r\nweb服务器一旦接收到http请求，经过自身的解析后就会调用web应用程序来处理业务逻辑，并得到web应用程序的返回值，再经过自身的封装发送给客户端。\r\n			</p>\r\n			<h2 id=\"二对于wsgi协议的理解\">\r\n				二、对于wsgi协议的理解\r\n			</h2>\r\n			<p>\r\n				在web服务器和web应用程序之间需要定义一个接口规则，这也叫协议，用于明确两者之间以什么样的形式交互数据。即：<strong>web服务器应该以什么样的形式调用web应用程序，而web应用程序又应该定义成什么形式。</strong> \r\n			</p>\r\n			<p>\r\n				python下规定的web服务的接口规则叫做wsgi，wsgi协议对于server和application的接口定义如下：\r\n			</p>\r\n			<p>\r\n				对于server调用规则的定义：\r\n			</p>\r\n<pre><span class=\"hljs-attr\">response</span> = application(environ, start_response)</pre>\r\n			<p>\r\n				对于application接口编码的定义：\r\n			</p>\r\n<pre><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">application</span><span class=\"hljs-params\">(environ, start_response)</span></span>:\r\n    status = <span class=\"hljs-string\">\'200 OK\'</span> response_headers = [(<span class=\"hljs-string\">\'Content-Type\'</span>, <span class=\"hljs-string\">\'text/plain\'</span>),]\r\n    start_response(status, response_headers) <span class=\"hljs-keyword\">return</span> [b<span class=\"hljs-string\">\'hello\'</span>,]</pre>\r\n			<p>\r\n				只要是遵从如上形式进一步封装server和application的，均称为实现了wsgi协议的server/application。\r\n			</p>\r\n			<p>\r\n				python内置提供了一个wsigref模块用于提供server，但是只能用于开发测试，django框架就是使用此模块作为它的server部分，也就说，实际生产中的server部分，还需要使用其他模块来实现。\r\n			</p>\r\n			<p>\r\n				任何web框架，可能没有实现server部分或者只实现一个简单的server，但是，web框架肯定实现了application部分。<strong>application部分完成了对一次请求的全流程处理</strong>，其中各环节都可以提供丰富的功能，比如请求和响应对象的封装、model/template的实现、中间件的实现等，让我们可以更加细粒度的控制请求/响应的流程。\r\n			</p>\r\n			<p>\r\n				<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181008160101110-1762669968.jpg\" /> \r\n			</p>\r\n			<h2 id=\"三自定义一个简单的基于wsgi协议的web框架\">\r\n				三、自定义一个简单的基于wsgi协议的web框架\r\n			</h2>\r\n			<p>\r\n				django框架的server部分由python内置的wsgiref模块提供，我们只需要编写application应用程序部分。\r\n			</p>\r\n<pre><span class=\"hljs-keyword\">from</span> wsgiref.simple_server <span class=\"hljs-keyword\">import</span> make_server <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(environ, start_response)</span>:</span> <span class=\"hljs-comment\"># wsgi协议规定的application部分的编码形式，可在此基础上扩展</span> status = <span class=\"hljs-string\">\'200 OK\'</span> respones_headers = []\r\n    \r\n    start_response(status, response_headers) <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">b\'hello\'</span>,] <span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\'__main__\'</span>:\r\n    httpd = make_server(<span class=\"hljs-string\">\'127.0.0.1\'</span>, <span class=\"hljs-number\">8080</span>, app)\r\n    httpd.serve_forever()</pre>\r\n			<p>\r\n				用以下图示表示简单的web请求流程架构（伪代码）<br />\r\n<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181008224931282-2126835772.jpg\" /> \r\n			</p>\r\n			<p>\r\n				<strong>web服务器就像是一颗心脏不停的跳动，驱动整个web系统为用户提供http访问服务，并调用application返回响应</strong> \r\n			</p>\r\n			<h2 id=\"四django中的server实现\">\r\n				四、django中的server实现\r\n			</h2>\r\n			<p>\r\n				django使用的底层server模块是基于python内置的wsgiref模块中的simple_server，每次django的启动都会执行如下run函数。run函数中会执行serve_forever，此步骤将会启动socket_server的无限循环，此时就可以循环提供请求服务，每次客户端请求到来，服务端就执行django提供的application模块。\r\n			</p>\r\n			<p>\r\n				django中server的启动----django.core.servers.basehttp.py\r\n			</p>\r\n<pre><span class=\"hljs-string\">\"\"\"\r\nHTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).\r\n\r\nBased on wsgiref.simple_server which is part of the standard library since 2.5.\r\n\r\nThis is a simple server for use in testing or debugging Django apps. It hasn\'t\r\nbeen reviewed for security issues. DON\'T USE IT FOR PRODUCTION USE!\r\n\"\"\"</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer)</span>:</span> server_address = (addr, port) <span class=\"hljs-keyword\">if</span> threading:\r\n        httpd_cls = type(<span class=\"hljs-string\">\'WSGIServer\'</span>, (socketserver.ThreadingMixIn, server_cls), {}) <span class=\"hljs-keyword\">else</span>:\r\n        httpd_cls = server_cls\r\n    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) <span class=\"hljs-keyword\">if</span> threading: <span class=\"hljs-comment\"># ThreadingMixIn.daemon_threads indicates how threads will behave on an</span> <span class=\"hljs-comment\"># abrupt shutdown; like quitting the server by the user or restarting</span> <span class=\"hljs-comment\"># by the auto-reloader. True means the server will not wait for thread</span> <span class=\"hljs-comment\"># termination before it quits. This will make auto-reloader faster</span> <span class=\"hljs-comment\"># and will prevent the need to kill the server manually if a thread</span> <span class=\"hljs-comment\"># isn\'t terminating correctly.</span> httpd.daemon_threads = <span class=\"hljs-keyword\">True</span> httpd.set_app(wsgi_handler)\r\n    httpd.serve_forever()</pre>\r\n			<p>\r\n				底层无限循环将作为web服务的主要驱动----socektserver.py\r\n			</p>\r\n<pre><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">serve_forever</span><span class=\"hljs-params\">(self, poll_interval=<span class=\"hljs-number\">0.5</span>)</span>:</span> <span class=\"hljs-string\">\"\"\"Handle one request at a time until shutdown.\r\n\r\n    Polls for shutdown every poll_interval seconds. Ignores\r\n    self.timeout. If you need to do periodic tasks, do them in\r\n    another thread.\r\n    \"\"\" selector:\r\n            selector.register(self, selectors.EVENT_READ) <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> self.__shutdown_request:\r\n                ready = selector.select(poll_interval) <span class=\"hljs-keyword\">if</span> ready:\r\n                    self._handle_request_noblock()\r\n\r\n                self.service_actions() <span class=\"hljs-keyword\">finally</span>:\r\n        self.__shutdown_request = <span class=\"hljs-keyword\">False</span> self.__is_shut_down.set()</span></pre>\r\n			<p>\r\n				server对于application的调用----wsgiref.handlers.py\r\n			</p>\r\n<pre><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(self, application)</span>:</span> <span class=\"hljs-string\">\"\"\"Invoke the application\"\"\"</span> <span class=\"hljs-comment\"># Note to self: don\'t move the close()!  Asynchronous servers shouldn\'t</span> <span class=\"hljs-comment\"># call close() from finish_response(), so if you close() anywhere but</span> <span class=\"hljs-comment\"># the double-error branch here, you\'ll break asynchronous servers by</span> <span class=\"hljs-comment\"># prematurely closing.  Async servers must return from \'run()\' without</span> <span class=\"hljs-comment\"># closing if there might still be output to iterate over.</span> <span class=\"hljs-keyword\">try</span>:\r\n        self.setup_environ()\r\n        self.result = application(self.environ, self.start_response)\r\n        self.finish_response() <span class=\"hljs-keyword\">except</span>: <span class=\"hljs-keyword\">try</span>:\r\n            self.handle_error() <span class=\"hljs-keyword\">except</span>: <span class=\"hljs-comment\"># If we get an error handling an error, just give up already!</span> self.close() <span class=\"hljs-keyword\">raise</span> <span class=\"hljs-comment\"># ...and let the actual server figure it out.</span></pre>\r\n			<h2 id=\"五django中的application实现\">\r\n				五、django中的application实现\r\n			</h2>\r\n			<p>\r\n				django的application模块是通过WSGIHandler的一个实例来提供的，此实例可以被call，然后根据wsgi的接口规则传入environ和start_response。所以本质上，django就是使用的内置python提供的wsgiref.simple_server再对application进行丰富的封装。大部分的django编码工作都在application部分。\r\n			</p>\r\n			<p>\r\n				application的编码定义部分----django.core.handlers.wsgi.py\r\n			</p>\r\n<pre><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WSGIHandler</span>(<span class=\"hljs-title\">base</span>.<span class=\"hljs-title\">BaseHandler</span>):</span> request_class = WSGIRequest <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, *args, **kwargs)</span></span>: <span class=\"hljs-keyword\">super</span>().__init_<span class=\"hljs-number\">_</span>(*args, **kwargs) <span class=\"hljs-keyword\">self</span>.load_middleware() <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__call__</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">self</span>, environ, start_response)</span></span>:\r\n        set_script_prefix(get_script_name(environ))\r\n        signals.request_started.send(sender=<span class=\"hljs-keyword\">self</span>.__class_<span class=\"hljs-number\">_</span>, environ=environ)\r\n        request = <span class=\"hljs-keyword\">self</span>.request_class(environ)\r\n        response = <span class=\"hljs-keyword\">self</span>.get_response(request)\r\n\r\n        response._handler_class = <span class=\"hljs-keyword\">self</span>.__class_<span class=\"hljs-number\">_</span> status = <span class=\"hljs-string\">\'%d %s\'</span> % (response.status_code, response.reason_phrase)\r\n        response_headers = list(response.items()) <span class=\"hljs-keyword\">for</span> c <span class=\"hljs-keyword\">in</span> response.cookies.values():\r\n            response_headers.append((<span class=\"hljs-string\">\'Set-Cookie\'</span>, c.output(header=<span class=\"hljs-string\">\'\'</span>)))\r\n        start_response(status, response_headers) <span class=\"hljs-keyword\">if</span> getattr(response, <span class=\"hljs-string\">\'file_to_stream\'</span>, None) is <span class=\"hljs-keyword\">not</span> None <span class=\"hljs-keyword\">and</span> environ.get(<span class=\"hljs-string\">\'wsgi.file_wrapper\'</span>):\r\n            response = environ[<span class=\"hljs-string\">\'wsgi.file_wrapper\'</span>](response.file_to_stream) <span class=\"hljs-keyword\">return</span> response</pre>\r\n			<h2 id=\"六django的底层调用链\">\r\n				六、django的底层调用链\r\n			</h2>\r\n			<p>\r\n				<img src=\"https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181006175526955-1852462410.jpg\" /> \r\n			</p>\r\n			<h2 id=\"七总结\">\r\n				七、总结\r\n			</h2>\r\n			<p>\r\n				web服务是基于socket的高层服务，所以web服务必须含有web服务器这一模块。<br />\r\nweb服务需要动态渲染数据，需要中间件来丰富功能，需要封装和解析来处理数据，所以web服务必须含有web应用程序这一模块。<br />\r\nweb框架是一种工具集，封装了各种功能的底层代码，提供给我们方便开发的接口。但不论是哪一种框架，它们的底层原理基本都是一致的。<br />\r\n应该深入学习、研究一个web框架，精通一门框架的实现原理和设计理念。\r\n			</p>\r\n		</div>\r\n		<div id=\"MySignature\">\r\n		</div>\r\n		<div class=\"clear\">\r\n		</div>\r\n<br />\r\n	</div>\r\n</div>',1,0,0,1,2,'article_imgs/4.jpg',3),(5,'js中的正则表达式【常用】','2018-11-04 16:08:01.704110','2018-11-04 16:08:01.704110','<div class=\"post\">\r\n	<h1 class=\"postTitle\">\r\n		<a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"https://www.cnblogs.com/zzzlw/p/9688597.html\">js中的正则表达式【常用】</a> \r\n	</h1>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div class=\"postBody\">\r\n		<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n			<p>\r\n				正则表达式是一种用于处理字符串匹配的强大工具，正则的核心在于匹配语法。<br />\r\n以下是常用的匹配规则\r\n			</p>\r\n<pre>.       除了换行符之外的任意一个字符\r\n\\       转义符，取消后面一个字符的含义，使其成为一个普通字符\r\n[]      括号里的任意一个字符\r\n[^]     不再括号里的任意一个字符\r\n\\d      数字0-9集合中的任意一个\r\n\\D      非数字集合中的任意一个\r\n\\w      数字、字母、下划线集合中的任意一个\r\n\\W      非数字、非字母、非下划线集合中的任意一个\r\n\\s      一个空白字符(即一个空格)\r\n\\S      非空白字符(空格)的任意一个字符\r\n^       表示开头\r\n$       表示结尾\r\n====================================\r\n*       匹配前面的字符0次或任意多次，如果匹配0次即是<span class=\"hljs-string\">\'\'</span> +       匹配前面的字符至少1次\r\n?       匹配前面的字符0次或1次，如果匹配0次即是<span class=\"hljs-string\">\'\'</span> {10}    匹配前面的字符连续10次\r\n{2,3}   匹配前面的字符至少2次，至多3次\r\n{2,}    匹配前面的字符至少2次\r\n|       表示或，注意此符号两边的匹配范围是尽量长的(贪婪)\r\n()      分组\r\n            作用1: 将多个项包围在一起组成一个独立的操作单元 (hello){2}匹配两个连续的hello字符串\r\n            作用2: 可以用于声明关注的某些项，并可以通过<span class=\"hljs-variable\">$1</span> <span class=\"hljs-variable\">$2</span>...的方式来引用，以便进一步通过运算处理\r\n                var phone1 = <span class=\"hljs-string\">\'18827368865\'</span>;\r\n                var phonePattern = /(\\d{3})(\\d{4})(\\d{4})/;\r\n                var phone2 = phone1.replace(phonePattern, <span class=\"hljs-keyword\">function</span> (result, <span class=\"hljs-variable\">$1</span>, <span class=\"hljs-variable\">$2</span>, <span class=\"hljs-variable\">$3</span>) { <span class=\"hljs-built_in\">return</span> <span class=\"hljs-variable\">$1</span> + <span class=\"hljs-string\">\'-\'</span> + <span class=\"hljs-variable\">$2</span> + <span class=\"hljs-string\">\'-\'</span> + <span class=\"hljs-variable\">$3</span>;\r\n                });\r\n                console.log(phone2);</pre>\r\n		</div>\r\n		<div id=\"MySignature\">\r\n		</div>\r\n		<div class=\"clear\">\r\n		</div>\r\n		<div id=\"blog_post_info_block\">\r\n			<div id=\"BlogPostCategory\">\r\n				分类: <a href=\"https://www.cnblogs.com/zzzlw/category/1208081.html\" target=\"_blank\">python</a> \r\n			</div>\r\n			<div id=\"EntryTag\">\r\n			</div>\r\n			<div id=\"blog_post_info\">\r\n				<div id=\"green_channel\">\r\n				</div>\r\n				<div id=\"author_profile\">\r\n					<div id=\"author_profile_info\" class=\"author_profile_info\">\r\n						<a href=\"http://home.cnblogs.com/u/zzzlw/\" target=\"_blank\"><img src=\"//pic.cnblogs.com/face/1381809/20180726204247.png\" class=\"author_avatar\" alt=\"\" /></a> \r\n						<div id=\"author_profile_detail\" class=\"author_profile_info\">\r\n							<a href=\"http://home.cnblogs.com/u/zzzlw/\">zzzzou</a><br />\r\n<a href=\"http://home.cnblogs.com/u/zzzlw/followees\">关注 - 4</a><br />\r\n<a href=\"http://home.cnblogs.com/u/zzzlw/followers\">粉丝 - 25</a> \r\n						</div>\r\n					</div>\r\n					<div class=\"clear\">\r\n					</div>\r\n					<div id=\"author_profile_honor\">\r\n					</div>\r\n					<div id=\"author_profile_follow\">\r\n					</div>\r\n				</div>\r\n				<div id=\"div_digg\">\r\n					<div class=\"diggit\">\r\n						<span class=\"diggnum\" id=\"digg_count\">0</span> \r\n					</div>\r\n					<div class=\"buryit\">\r\n						<span class=\"burynum\" id=\"bury_count\">0</span> \r\n					</div>\r\n					<div class=\"clear\">\r\n					</div>\r\n					<div class=\"diggword\" id=\"digg_tips\">\r\n					</div>\r\n				</div>\r\n			</div>\r\n			<div class=\"clear\">\r\n			</div>\r\n			<div id=\"post_next_prev\">\r\n				<a href=\"https://www.cnblogs.com/zzzlw/p/9626916.html\" class=\"p_n_p_prefix\">« </a> 上一篇：<a href=\"https://www.cnblogs.com/zzzlw/p/9626916.html\">html-css-js基本理解和简单总结</a><br />\r\n<a href=\"https://www.cnblogs.com/zzzlw/p/9693527.html\" class=\"p_n_p_prefix\">» </a> 下一篇：<a href=\"https://www.cnblogs.com/zzzlw/p/9693527.html\">js的事件学习笔记</a><br />\r\n			</div>\r\n		</div>\r\n	</div>\r\n	<div class=\"postDesc\">\r\n		posted @ <span id=\"post-date\">2018-09-21 21:42</span> <a href=\"https://www.cnblogs.com/zzzlw/\">zzzzou</a> 阅读(<span id=\"post_view_count\">14</span>) 评论(<span id=\"post_comment_count\">0</span>) <a href=\"https://i.cnblogs.com/EditPosts.aspx?postid=9688597\">编辑</a> <a href=\"#\">收藏</a> \r\n	</div>\r\n</div>',1,0,0,1,6,'article_imgs/5.jpg',2),(6,'html-css-js基本理解和简单总结','2018-11-04 16:08:29.268121','2018-11-04 16:08:29.268121','<div class=\"post\">\r\n	<h1 class=\"postTitle\">\r\n		<a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"https://www.cnblogs.com/zzzlw/p/9626916.html\">html-css-js基本理解和简单总结</a> \r\n	</h1>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div class=\"postBody\">\r\n		<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n			<p class=\"toc\">\r\n				目录\r\n			</p>\r\n			<ul>\r\n				<li>\r\n					<a href=\"#一对于网页的基本理解\">一、对于网页的基本理解</a> \r\n					<ul>\r\n						<li>\r\n							<a href=\"#网页是一种数据展示和信息交互的载体\">1、网页是一种数据展示和信息交互的载体</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#网页组成部分\">2、网页组成部分</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#支撑一个网页的技术模块\">3、支撑一个网页的技术模块</a> \r\n						</li>\r\n					</ul>\r\n				</li>\r\n				<li>\r\n					<a href=\"#二html的理解和技术笔记\">二、html的理解和技术笔记</a> \r\n					<ul>\r\n						<li>\r\n							<a href=\"#html理解\">1、html理解</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#html技术笔记-html标签\">2、html技术笔记-html标签</a> \r\n						</li>\r\n					</ul>\r\n				</li>\r\n				<li>\r\n					<a href=\"#三css的理解和技术笔记\">三、css的理解和技术笔记</a> \r\n					<ul>\r\n						<li>\r\n							<a href=\"#css理解\">1、css理解</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#css技术笔记\">2、css技术笔记</a> \r\n						</li>\r\n					</ul>\r\n				</li>\r\n				<li>\r\n					<a href=\"#四js的理解和技术笔记\">四、js的理解和技术笔记</a> \r\n					<ul>\r\n						<li>\r\n							<a href=\"#js理解\">1、js理解</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#js技术笔记-基本知识\">2、js技术笔记-基本知识</a> \r\n						</li>\r\n					</ul>\r\n				</li>\r\n			</ul>\r\n			<hr />\r\n			<h2 id=\"一对于网页的基本理解\">\r\n				一、对于网页的基本理解\r\n			</h2>\r\n			<h3 id=\"网页是一种数据展示和信息交互的载体\">\r\n				1、网页是一种数据展示和信息交互的载体\r\n			</h3>\r\n			<p>\r\n				生活中，我们通过各种各样的方式获取信息，网页是目前被使用最频繁的一种。<br />\r\n早年网页的目的更多在于数据的展示，现在的网页为了提供更好的用户体验，在保持原有目的的基础上，越来越关注：\r\n			</p>\r\n			<ol>\r\n				<li>\r\n					界面的美观度\r\n				</li>\r\n				<li>\r\n					交互性的提升\r\n				</li>\r\n				<li>\r\n					性能的优化和传输效率的提升\r\n				</li>\r\n			</ol>\r\n			<h3 id=\"网页组成部分\">\r\n				2、网页组成部分\r\n			</h3>\r\n			<ol>\r\n				<li>\r\n					网页结构，关注网页\'长什么样\'<br />\r\n结构提供了网页骨架、布局\r\n				</li>\r\n				<li>\r\n					网页数据，关注网页\'提供了什么内容\'<br />\r\n数据是网页承载的主要内容，完成了网页的数据展示功能\r\n				</li>\r\n				<li>\r\n					网页样式，关注网页\'好不好看\'<br />\r\n样式是网页的外观，提供对用户最直观的感受<br />\r\n样式审美和整体风格也代表着隐式的数据表达\r\n				</li>\r\n				<li>\r\n					网页动作，关注网页\'交互性\'<br />\r\n动作提供了交互，良好的交互可以提升用户的体验<br />\r\n动作优化了性能，良好的数据传输设计(如ajax)可以增加传输效率\r\n				</li>\r\n			</ol>\r\n			<h3 id=\"支撑一个网页的技术模块\">\r\n				3、支撑一个网页的技术模块\r\n			</h3>\r\n			<ol>\r\n				<li>\r\n					结构:html\r\n				</li>\r\n				<li>\r\n					数据:web框架(数据处理)+数据库(数据存储)\r\n				</li>\r\n				<li>\r\n					样式:css\r\n				</li>\r\n				<li>\r\n					动作:js\r\n				</li>\r\n			</ol>\r\n			<hr />\r\n			<h2 id=\"二html的理解和技术笔记\">\r\n				二、html的理解和技术笔记\r\n			</h2>\r\n			<h3 id=\"html理解\">\r\n				1、html理解\r\n			</h3>\r\n			<p>\r\n				就像造房子一样，一栋房子有多个组成部分，html类似于房子的户型，它设计了房子的整体架构、分区、布局，而且还定义了每个区块的功能作用。html技术为后续入住的数据事先搭建好了对应的空间。\r\n			</p>\r\n			<h3 id=\"html技术笔记-html标签\">\r\n				2、html技术笔记-html标签\r\n			</h3>\r\n<pre>html     代表包含一个网页文档，是一个网页的根元素(某些浏览器将<span class=\"hljs-keyword\">body</span>作为根元素)\r\n    head     代表文档的头部，包含控制信息\r\n    meta     代表控制信息，通过标签中的属性来提供页面控制，如:charset=<span class=\"hljs-symbol\">\'UTF</span>-<span class=\"hljs-number\">8</span>\'控制编码格式\r\n    title    代表网页标题\r\n    link     外部文件链接，主要是css链接 <span class=\"hljs-keyword\">body</span> 代表文档的主体，包含数据、主体骨架、布局、样式、行为事件和回调函数等\r\n    script   代表一个js代码的引用,包含内联的js代码或一个js文件地址\r\n    a        代表一个链接，包含一个去往某链接的文字说明\r\n    h1-<span class=\"hljs-number\">6</span> 代表文章主题，h1的字体最大\r\n    p        代表一个段落，包含段落中的内容\r\n    img      代表一个图像，包含一个展示图像\r\n    i        代表一个图标，包含一个图标\r\n    div      代表一个盒子模型，一般用于布局\r\n    span     代表一个行内文本，一般用于需要特别处理的行内文本标记\r\n    hr/br    代表水平分隔符/换行符\r\n    button   代表一个按钮，button在form中会默认<span class=\"hljs-keyword\">type</span>=submit\r\n\r\n    form     代表一个表单，可以内含很多表单组件，一般用于用户数据提交\r\n    input    代表一个表单组件，通过<span class=\"hljs-keyword\">type</span>来切换不同功能，一般用于数据的输入 <span class=\"hljs-literal\">text</span> 代表一个文本输入框，一般用于输入小段文本\r\n        email      代表一个email输入框,会对输入的邮件格式做格式判断\r\n        password   代表一个密码输入框，输入的密码会被转换成一个黑点或者星号\r\n        radio      代表一个单选框，多个相同name的单选框组成一个组，选项互斥\r\n        checkbox   代表一个复选框，多个项目name的复选框组成一个组\r\n    textarea   代表一个文本输入域，一般用于输入大段文本 <span class=\"hljs-keyword\">select</span> 代表一个下拉框，包含多个下拉选项\r\n        option     代表一个下拉选项 <span class=\"hljs-keyword\">label</span> 代表一个标记，一般用于指向对应的输入框用于实现点击<span class=\"hljs-keyword\">label</span>时输入框产生焦点 <span class=\"hljs-keyword\">file</span> 代表一个文件上传框\r\n    submit     代表提交表单，一旦点击，所属表单的所有组件值会被统一提交\r\n\r\n    table    代表一个表格，包含很多表格元素\r\n        thead      代表表格头部，一般是一行\r\n            tr     代表一行\r\n            th     代表表格数据的名称，即属性名，如：名字、年龄、学校、工资等\r\n        tbody      代表表格数据主体\r\n            tr     同上\r\n            td     代表数据单元格，包含一个单元格的数据\r\n\r\n    ul/ol    代表一个无序/有序列表，包含列表项目\r\n        li         代表一个列表项目</pre>\r\n			<hr />\r\n			<h2 id=\"三css的理解和技术笔记\">\r\n				三、css的理解和技术笔记\r\n			</h2>\r\n			<h3 id=\"css理解\">\r\n				1、css理解\r\n			</h3>\r\n			<p>\r\n				css类似于房子的装修，装修让这栋房子看上去更加的美观，装修定义了每一块墙面该粉刷成什么颜色，地板应该如何规划，是长方形还是正方形。装修应该从整体主题出发，依据优秀的审美素养规划设计每一个区域的样式设计，整体装修方案也表达了这栋房子的主题。\r\n			</p>\r\n			<h3 id=\"css技术笔记\">\r\n				2、css技术笔记\r\n			</h3>\r\n			<h4 id=\"选择器\">\r\n				选择器\r\n			</h4>\r\n			<p>\r\n				选择器的目的是为了得到对目标元素的引用，一旦得到引用，就可以在此引用上执行各类操作。一个元素有很多不同的表征，这些都可以作为寻找引用的依据。\r\n			</p>\r\n<pre><span class=\"hljs-number\">1</span>. 基本查找方式:\r\n    id: id是一个标签元素在html中的唯一标识，使用id可以快速且唯一的寻找到元素引用 <span class=\"hljs-keyword\">class</span>: <span class=\"hljs-keyword\">class</span>表示了一个标签元素所属的类，类和标签属于多对多关系，一个类可以有多个标签，一个标签也可以属于多个类，使用<span class=\"hljs-keyword\">class</span>会寻找到归属于此类的多个标签元素\r\n    tagName: tagName是一个标签的名称，通过标签名可以找到文档中所有同名标签\r\n    优先级: 使用id &gt; 使用<span class=\"hljs-keyword\">class</span> &gt; 使用tagName <span class=\"hljs-number\">2</span>. 高级查找方式: <span class=\"hljs-keyword\">div</span> p: 表示文档中，所有<span class=\"hljs-keyword\">div</span>子树中的p都被抓取，不论p是<span class=\"hljs-keyword\">div</span>的儿子辈还是孙子辈 <span class=\"hljs-keyword\">div</span>&gt;p: 表示文档中，所有<span class=\"hljs-keyword\">div</span>子树中的直接后辈p都被抓取，即p必须是<span class=\"hljs-keyword\">div</span>的儿子辈 <span class=\"hljs-keyword\">div</span>#box1: 表示文档中，所有id是box1的<span class=\"hljs-keyword\">div</span>(其实应该只有<span class=\"hljs-number\">1</span>个)，查询结果等价于#box1 <span class=\"hljs-keyword\">div</span>.box1: 表示文档中，所有<span class=\"hljs-keyword\">class</span>中含有box1的<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">div</span>, p, li: 表示组合，即对多个元素组合执行相同的操作 <span class=\"hljs-number\">3</span>. 属性查找\r\n    [school]: 表示文档中，所有含有school属性的所有标签 <span class=\"hljs-keyword\">div</span>[school]: 表示文档中，含有school属性的所有<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">div</span>[school=<span class=\"hljs-string\">\'abc\'</span>]: 表示文档中，含有school属性且值为<span class=\"hljs-string\">\'abc\'</span>的所有<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">div</span>[school^=<span class=\"hljs-string\">\'a\'</span>]: 表示文档中，含有school属性且值以<span class=\"hljs-string\">\'a\'</span>开头的所有<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">div</span>[school$=<span class=\"hljs-string\">\'a\'</span>]: 表示文档中，含有school属性且值以<span class=\"hljs-string\">\'a\'</span>结尾的所有<span class=\"hljs-keyword\">div</span> <span class=\"hljs-number\">4</span>. 伪类选择器\r\n    某元素:link  表示当此元素未被访问时的样式(即初始默认样式)\r\n    某元素:hover 表示当鼠标移到此元素上时的样式\r\n    某元素:active 表示当鼠标点击瞬间(未释放鼠标)时的样式\r\n    某元素:visited 表示当此元素被访问过(释放鼠标后)时的样式\r\n    以上<span class=\"hljs-number\">4</span>种伪类选择器定义了当发生某些动作时的样式改变，可以用于提供简单的界面交互\r\n\r\n    p:first-child 表示当p是某一个父元素的第一个子元素时被获取\r\n    p:last-child 表示当p是某一个父元素的最后一个子元素时被获取\r\n    p:nth-child(x) 表示当p是某一个父元素的指定第x个子元素时被获取\r\n    p:nth-child(<span class=\"hljs-number\">2</span>n) 表示当p是某一个父元素的指定偶数个子元素时被获取\r\n    以上<span class=\"hljs-number\">4</span>种伪类的理解容易发生偏差，且使用时容易出错，产生意外结果 <span class=\"hljs-number\">5</span>. 伪元素选择器\r\n    li:first-letter 表示此元素的第一个文本字符被获取\r\n    li:before\r\n    li:after\r\n    以上<span class=\"hljs-number\">2</span>种一般配合content属性使用，表示此元素的原有文本前/后增加对应内容,first-letter不能应用于a等行内元素</pre>\r\n			<h4 id=\"样式\">\r\n				样式\r\n			</h4>\r\n			<p>\r\n				字体属性<br />\r\n颜色属性<br />\r\n文本属性<br />\r\n背景属性<br />\r\n元素分类:块级、行内、行内块级\r\n			</p>\r\n			<h4 id=\"盒子模型\">\r\n				盒子模型\r\n			</h4>\r\n			<p>\r\n				一个盒子模型可以被认为是一个操作单元，页面的布局由多个盒子组成\r\n			</p>\r\n			<p>\r\n				外边距margin：代表盒子外边界到边框的距离<br />\r\n边框border：代表盒子边框，边框可以有一定的宽度<br />\r\n内边距padding：代表盒子边框到内容区的距离<br />\r\n内容区width/height：代表内容区的宽高\r\n			</p>\r\n			<h4 id=\"浮动\">\r\n				浮动\r\n			</h4>\r\n			<p>\r\n				html文档被浏览器所解析时，浏览器会将各元素按照标准文档流放入页面中。浮动的作用是将某个元素脱离文档流，看上去就好像它悬浮在原有页面上一样。浮动使用float属性设置，可以选择向左或者向右。<br />\r\n此外，浮动的元素会被看作是块级元素，即一个行内元素一旦浮动，就可拥有width和height属性浮动一般会配合盒子模型使用，将浮动元素包含在盒子中，再通过盒子完成页面布局。子元素的浮动一般会导致父元素的height塌陷至0，导致父元素盒子不可见，此时需要在父元素上完成清除浮动。\r\n			</p>\r\n			<p>\r\n				清除浮动<br />\r\n浮动可以实现多个块级元素并排在一行。浮动元素会提升层级，这会导致父元素高度塌陷。<br />\r\n父元素设置overflow即可将高度扩展至子元素中最大的高度。<br />\r\n多个浮动的元素在一行，通过clear 的left和right可以取消并排效果，注意clear只应用于元素自身。\r\n			</p>\r\n			<h4 id=\"定位\">\r\n				定位\r\n			</h4>\r\n			<p>\r\n				相对定位: 不脱离标准流，原区域保留，无浮动效果<br />\r\n绝对定位: 脱离标准流，原区域不保留，浮动效果<br />\r\n固定定位: 脱离标准流,原区域不保留，浮动效果，将会固定在指定区域即使发生滚动\r\n			</p>\r\n			<hr />\r\n			<h2 id=\"四js的理解和技术笔记\">\r\n				四、js的理解和技术笔记\r\n			</h2>\r\n			<h3 id=\"js理解\">\r\n				1、js理解\r\n			</h3>\r\n			<p>\r\n				js类似于房子里的家具，家具提供了交互性功能，给用户提供了更方便、快捷、简单的方法用于处理各类事务：\r\n			</p>\r\n<pre>以前我们需要用钥匙开门，现在有了智能锁只需要指纹\r\n以前我们需要烟囱排烟，现在有了油烟机只需要打开开关\r\n以前我们需要烧水洗澡，现在有了热水器\r\n以前我们需要将食物放到水里保质，现在有了冰箱\r\n以前我们需要到社区大队看电影，现在有了电视、电脑</pre>\r\n			<p>\r\n				家具提供了更优秀的用户体验，也提升了用户完成某一件事的效率。\r\n			</p>\r\n			<p>\r\n				js是运行在客户端上的编程语言，与后端语言本质上是一样的，只是适用的场景不同而已。<br />\r\njs由浏览器负责解释执行，js的使用可以减轻服务器的压力，比如使用js检测输入数据格式、局部数据刷新等等。<br />\r\njs是解释型语言，浏览器会实时编译，所以js和python文件一样，都是直观可见的文本类型源代码。\r\n			</p>\r\n			<h3 id=\"js技术笔记-基本知识\">\r\n				2、js技术笔记-基本知识\r\n			</h3>\r\n			<h4 id=\"语法\">\r\n				语法\r\n			</h4>\r\n<pre><span class=\"hljs-bullet\">1. </span>驼峰式命名 <span class=\"hljs-bullet\">2. </span>;号结尾 <span class=\"hljs-bullet\">3. </span>{}代码块 <span class=\"hljs-bullet\">4. </span>var 变量声明</pre>\r\n			<h4 id=\"数据类型\">\r\n				数据类型\r\n			</h4>\r\n<pre>Number\r\n        数字类型，数字类型有一个特殊值:NaN，代表当尝试转换成Number类型失败时的值，如Number(<span class=\"hljs-comment\">\'abc\')</span> <span class=\"hljs-built_in\">String</span> 字符串类型，js中的字符串也是不可变对象，即所有尝试针对原字符串修改的操作都会返回一个新字符串\r\n        字符串可以使用[]和charAt()访问，也可以通过<span class=\"hljs-keyword\">for</span>来遍历\r\nBoolean\r\n        布尔类型，<span class=\"hljs-literal\">true</span>或者<span class=\"hljs-literal\">false</span>，\r\n            注意Boolean(<span class=\"hljs-comment\">\'false\')的值是true,</span> 注意Boolean([])的值是<span class=\"hljs-literal\">true</span>，\r\n        以下值的布尔值是<span class=\"hljs-literal\">false</span>: <span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">-0</span>,<span class=\"hljs-comment\">\'\',NaN,undefined,null,false</span> 其他值都是<span class=\"hljs-literal\">true</span> <span class=\"hljs-built_in\">Array</span> 数组类型，js的数组类型也是动态的，不仅长度可变，也可以涵盖多个不同类型的元素\r\n        注意，如下方式遍历数组，将会得到数组的元素下标\r\n            var arr = [<span class=\"hljs-comment\">\'a\',\'b\',c\'];</span> <span class=\"hljs-keyword\">for</span>(var i <span class=\"hljs-keyword\">in</span> arr){\r\n                console.<span class=\"hljs-built_in\">log</span>(i);\r\n                } <span class=\"hljs-built_in\">Date</span> 时间类型，用于表示时间，初始值是当前时间。时间对象有很多关于时间操作的函数可以使用。\r\nMath\r\n        数学函数，使用Math.<span class=\"hljs-built_in\">abs</span>(x)获取绝对值等 <span class=\"hljs-built_in\">RegExp</span> 正则类型，用于表示一个正则表达式，一般用于处理字符串\r\n\r\nundefined和<span class=\"hljs-literal\">null</span> undefined表示声明了，但是未定义值 <span class=\"hljs-literal\">null</span>表示声明了，但是定义了一个空值</pre>\r\n			<h4 id=\"流程控制\">\r\n				流程控制\r\n			</h4>\r\n<pre>判断 <span class=\"hljs-keyword\">if</span> [<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>] <span class=\"hljs-keyword\">else</span> 分支判断 <span class=\"hljs-keyword\">switch</span>(x) { <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>: <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-comment\">//code</span> } <span class=\"hljs-keyword\">for</span>循环 <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>, len = x.length; i &lt; len; i++) { <span class=\"hljs-comment\">//code</span> } <span class=\"hljs-keyword\">while</span>循环 <span class=\"hljs-keyword\">while</span>(condition){ <span class=\"hljs-comment\">//code</span> } <span class=\"hljs-keyword\">do</span>循环（至少执行一次） <span class=\"hljs-keyword\">do</span>{ <span class=\"hljs-comment\">//code</span> }<span class=\"hljs-keyword\">while</span>(condition)</pre>\r\n			<h4 id=\"函数\">\r\n				函数\r\n			</h4>\r\n<pre>函数声明 --&gt; 定义函数方法<span class=\"hljs-number\">1</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">args</span>)</span>{ <span class=\"hljs-comment\">//code</span> }\r\n\r\n函数表达式 --&gt; 定义函数方法<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">args</span>)</span>{ <span class=\"hljs-comment\">//code</span> }</pre>\r\n			<h4 id=\"自定义对象\">\r\n				自定义对象\r\n			</h4>\r\n<pre>字面量方式 <span class=\"hljs-keyword\">var</span> stu = { <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">\'xiaoming\'</span>, <span class=\"hljs-attr\">age</span>:<span class=\"hljs-number\">26</span> };\r\n\r\n构造函数方式 <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Stu</span>(<span class=\"hljs-params\">stuName, stuAge</span>)</span>{ <span class=\"hljs-keyword\">this</span>.stuName = stuName; <span class=\"hljs-keyword\">this</span>.stuAge = stuAge;\r\n    } <span class=\"hljs-keyword\">var</span> stu = <span class=\"hljs-keyword\">new</span> Stu(<span class=\"hljs-string\">\'xiaoming\'</span>, <span class=\"hljs-number\">26</span>);</pre>\r\n			<h4 id=\"dom\">\r\n				DOM\r\n			</h4>\r\n			<ol>\r\n				<li>\r\n					元素控制<br />\r\n一个html页面可以被看成是一棵树，每个节点都是html标签。js可以操作这棵树，提供了很多操作方法。<br />\r\n使用js，可以方便的增删改查html元素，这为我们提供了控制html页面结构的途径。\r\n				</li>\r\n				<li>\r\n					属性控制<br />\r\njs在获取到相应的元素后，可以控制此元素的属性，除了html元素自身的属性之外，还可以通过style控制<br />\r\n元素的样式属性，这为我们提供了控制html页面样式的途径。\r\n				</li>\r\n				<li>\r\n					事件控制<br />\r\njs还可以控制元素的事件响应，注册相应的事件并提供预定义的回调函数，一旦发生期望的事件即可以执行<br />\r\n回调函数。通过事件控制，js可以快速的增加、删除、修改元素的行为，这为我们提供了控制html页面行为<br />\r\n的途径。\r\n				</li>\r\n			</ol>\r\n			<h4 id=\"bom\">\r\n				BOM\r\n			</h4>\r\n			<p>\r\n				js可以通过某些对象来控制浏览器，如:\r\n			</p>\r\n<pre>navigator\r\n    location\r\n    history\r\n    screen <span class=\"hljs-built_in\">window</span></pre>\r\n		</div>\r\n		<div id=\"MySignature\">\r\n		</div>\r\n		<div class=\"clear\">\r\n		</div>\r\n<br />\r\n	</div>\r\n</div>',1,0,0,1,6,'article_imgs/6.jpg',2),(7,'python的socket.recv函数陷阱','2018-11-04 16:09:03.475460','2018-11-04 16:09:03.475460','<div class=\"postBody\">\r\n	<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n		<p class=\"toc\">\r\n			目录\r\n		</p>\r\n		<ul>\r\n			<li>\r\n				<a href=\"#前言\">前言</a> \r\n			</li>\r\n			<li>\r\n				<a href=\"#一个粘包实验\">一个粘包实验</a> \r\n			</li>\r\n			<li>\r\n				<a href=\"#执行结果\">执行结果</a> \r\n			</li>\r\n			<li>\r\n				<a href=\"#排错思路\">排错思路</a> \r\n			</li>\r\n			<li>\r\n				<a href=\"#解决和总结\">解决和总结</a> \r\n			</li>\r\n		</ul>\r\n		<h1 id=\"前言\">\r\n			前言\r\n		</h1>\r\n		<p>\r\n			惯例练习历史实验，在编写tcp数据流粘包实验的时候，发现一个奇怪的现象。当远程执行的命令返回结果很短的时候可以正常执行，但返回结果很长时，就会发生json解码错误，故将排错和解决方法记录下来。\r\n		</p>\r\n		<h1 id=\"一个粘包实验\">\r\n			一个粘包实验\r\n		</h1>\r\n		<p>\r\n			服务端(用函数）：\r\n		</p>\r\n<pre class=\"python\"><span class=\"hljs-keyword\">import</span> socket <span class=\"hljs-keyword\">import</span> json <span class=\"hljs-keyword\">import</span> struct <span class=\"hljs-keyword\">import</span> subprocess <span class=\"hljs-keyword\">import</span> sys <span class=\"hljs-keyword\">from</span> concurrent.futures <span class=\"hljs-keyword\">import</span> ThreadPoolExecutor <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">init_socket</span><span class=\"hljs-params\">()</span>:</span> addr = (<span class=\"hljs-string\">\'127.0.0.1\'</span>, <span class=\"hljs-number\">8080</span>)\r\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    server.bind(addr)\r\n    server.listen(<span class=\"hljs-number\">5</span>)\r\n    print(<span class=\"hljs-string\">\'start listening...\'</span>) <span class=\"hljs-keyword\">return</span> server <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(request)</span>:</span> command = request.decode(<span class=\"hljs-string\">\'utf-8\'</span>)\r\n    obj = subprocess.Popen(command,\r\n                           shell=<span class=\"hljs-keyword\">True</span>,\r\n                           stdout=subprocess.PIPE,\r\n                           stderr=subprocess.PIPE)\r\n    result = obj.stdout.read() + obj.stderr.read() <span class=\"hljs-comment\"># 如果是win还需要转换编码</span> <span class=\"hljs-keyword\">if</span> sys.platform == <span class=\"hljs-string\">\'win32\'</span>:\r\n        result = result.decode(<span class=\"hljs-string\">\'gbk\'</span>).encode(<span class=\"hljs-string\">\'utf-8\'</span>) <span class=\"hljs-keyword\">return</span> result <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">build_header</span><span class=\"hljs-params\">(data_len)</span>:</span> dic = { <span class=\"hljs-string\">\'cmd_type\'</span>: <span class=\"hljs-string\">\'shell\'</span>, <span class=\"hljs-string\">\'data_len\'</span>: data_len,\r\n    } <span class=\"hljs-keyword\">return</span> json.dumps(dic).encode(<span class=\"hljs-string\">\'utf-8\'</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send</span><span class=\"hljs-params\">(conn, response)</span>:</span> data_len = len(response)\r\n    header = build_header(data_len)\r\n    header_len = len(header)\r\n    struct_bytes = struct.pack(<span class=\"hljs-string\">\'i\'</span>, header_len) <span class=\"hljs-comment\"># 粘包发送</span> conn.send(struct_bytes)\r\n    conn.send(header)\r\n    conn.send(response) <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">task</span><span class=\"hljs-params\">(conn)</span>:</span> <span class=\"hljs-keyword\">try</span>: <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">True</span>: <span class=\"hljs-comment\"># 消息循环</span> request = conn.recv(<span class=\"hljs-number\">1024</span>) <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> request: <span class=\"hljs-comment\"># 链接失效</span> <span class=\"hljs-keyword\">raise</span> ConnectionResetError\r\n\r\n            response = handle(request)\r\n            send(conn, response) <span class=\"hljs-keyword\">except</span> ConnectionResetError:\r\n        msg = <span class=\"hljs-string\">f\'链接-<span class=\"hljs-subst\">{conn.getpeername()}</span>失效\'</span> conn.close() <span class=\"hljs-keyword\">return</span> msg <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">show_res</span><span class=\"hljs-params\">(future)</span>:</span> result = future.result()\r\n    print(result) <span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\'__main__\'</span>:\r\n    max_thread = <span class=\"hljs-number\">5</span> futures = []\r\n    server = init_socket() <span class=\"hljs-keyword\">with</span> ThreadPoolExecutor(max_thread) <span class=\"hljs-keyword\">as</span> pool: <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">True</span>: <span class=\"hljs-comment\"># 链接循环</span> conn, addr = server.accept()\r\n            print(<span class=\"hljs-string\">f\'一个客户端上线<span class=\"hljs-subst\">{addr}</span>\'</span>)\r\n\r\n            future = pool.submit(task, conn)\r\n            future.add_done_callback(show_res)\r\n            futures.append(future)</pre>\r\n		<p>\r\n			客户端（用类）：\r\n		</p>\r\n<pre class=\"python\"><span class=\"hljs-keyword\">import</span> socket <span class=\"hljs-keyword\">import</span> struct <span class=\"hljs-keyword\">import</span> time <span class=\"hljs-keyword\">import</span> json <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span><span class=\"hljs-params\">(object)</span>:</span> addr = (<span class=\"hljs-string\">\'127.0.0.1\'</span>, <span class=\"hljs-number\">8080</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span> self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        self.socket.connect(self.addr)\r\n        print(<span class=\"hljs-string\">\'连接上服务器\'</span>) <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">get_request</span><span class=\"hljs-params\">(self)</span>:</span> <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">True</span>:\r\n            request = input(<span class=\"hljs-string\">\'&gt;&gt;&gt;\'</span>).strip() <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> request: <span class=\"hljs-keyword\">continue</span> <span class=\"hljs-keyword\">return</span> request <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">recv</span><span class=\"hljs-params\">(self)</span>:</span> <span class=\"hljs-comment\"># 拆包接收</span> struct_bytes = self.socket.recv(<span class=\"hljs-number\">4</span>)\r\n        header_len = struct.unpack(<span class=\"hljs-string\">\'i\'</span>, struct_bytes)[<span class=\"hljs-number\">0</span>]\r\n        header_bytes = self.socket.recv(header_len)\r\n        header = json.loads(header_bytes.decode(<span class=\"hljs-string\">\'utf-8\'</span>))\r\n        data_len = header[<span class=\"hljs-string\">\'data_len\'</span>]\r\n\r\n        gap_abs = data_len % <span class=\"hljs-number\">1024</span> count = data_len // <span class=\"hljs-number\">1024</span> recv_data = <span class=\"hljs-string\">b\'\'</span> <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(count):\r\n            data = self.socket.recv(<span class=\"hljs-number\">1024</span>)\r\n            recv_data += data\r\n        recv_data += self.socket.recv(gap_abs)\r\n\r\n        print(<span class=\"hljs-string\">\'recv data len is:\'</span>, len(recv_data)) <span class=\"hljs-keyword\">return</span> recv_data <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(self)</span>:</span> <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">True</span>: <span class=\"hljs-comment\"># 消息循环</span> request = self.get_request()\r\n            self.socket.send(request.encode(<span class=\"hljs-string\">\'utf-8\'</span>))\r\n            response = self.recv()\r\n            print(response.decode(<span class=\"hljs-string\">\'utf-8\'</span>)) <span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\'__main__\'</span>:\r\n    client = Client()\r\n    client.run()</pre>\r\n		<h1 id=\"执行结果\">\r\n			执行结果\r\n		</h1>\r\n		<p>\r\n			在执行dir/ipconfig等命令时可以正常获取结果，但是在执行tasklist命令时，发现没有获取完整的执行结果，而且下一条命令将发生报错：\r\n		</p>\r\n<pre class=\"python\">Traceback (most recent call last):\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/world.py\"</span>, line <span class=\"hljs-number\">62</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;\r\n    client.run()\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/world.py\"</span>, line <span class=\"hljs-number\">57</span>, <span class=\"hljs-keyword\">in</span> run\r\n    response = self.recv()\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/world.py\"</span>, line <span class=\"hljs-number\">35</span>, <span class=\"hljs-keyword\">in</span> recv\r\n    header = json.loads(header_bytes.decode(<span class=\"hljs-string\">\'utf-8\'</span>))\r\n  File <span class=\"hljs-string\">\"C:\\Users\\zouliwei\\AppData\\Local\\Programs\\Python\\Python36\\lib\\json\\__init__.py\"</span>, line <span class=\"hljs-number\">354</span>, <span class=\"hljs-keyword\">in</span> loads <span class=\"hljs-keyword\">return</span> _default_decoder.decode(s)\r\n  File <span class=\"hljs-string\">\"C:\\Users\\zouliwei\\AppData\\Local\\Programs\\Python\\Python36\\lib\\json\\decoder.py\"</span>, line <span class=\"hljs-number\">339</span>, <span class=\"hljs-keyword\">in</span> decode\r\n    obj, end = self.raw_decode(s, idx=_w(s, <span class=\"hljs-number\">0</span>).end())\r\n  File <span class=\"hljs-string\">\"C:\\Users\\zouliwei\\AppData\\Local\\Programs\\Python\\Python36\\lib\\json\\decoder.py\"</span>, line <span class=\"hljs-number\">357</span>, <span class=\"hljs-keyword\">in</span> raw_decode <span class=\"hljs-keyword\">raise</span> JSONDecodeError(<span class=\"hljs-string\">\"Expecting value\"</span>, s, err.value) <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">None</span> json.decoder.JSONDecodeError: Expecting value: line <span class=\"hljs-number\">1</span> column <span class=\"hljs-number\">1</span> (char <span class=\"hljs-number\">0</span>)</pre>\r\n		<h1 id=\"排错思路\">\r\n			排错思路\r\n		</h1>\r\n		<p>\r\n			1、错误明确指示是json的解码发生了错误，解码错误应该是来自于<strong>解码的数据编码不正确</strong>或者读取的<strong>数据不完整</strong>。<br />\r\n2、发生错误的函数在客户端，错误在第6行，摘出如下：\r\n		</p>\r\n<pre class=\"python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">recv</span><span class=\"hljs-params\">(self)</span>:</span> <span class=\"hljs-comment\"># 拆包接收</span> struct_bytes = self.socket.recv(<span class=\"hljs-number\">4</span>)\r\n        header_len = struct.unpack(<span class=\"hljs-string\">\'i\'</span>, struct_bytes)[<span class=\"hljs-number\">0</span>]\r\n        header_bytes = self.socket.recv(header_len)\r\n        header = json.loads(header_bytes.decode(<span class=\"hljs-string\">\'utf-8\'</span>)) <span class=\"hljs-comment\"># 此行发生错误</span> data_len = header[<span class=\"hljs-string\">\'data_len\'</span>]\r\n\r\n        gap_abs = data_len % <span class=\"hljs-number\">1024</span> count = data_len // <span class=\"hljs-number\">1024</span> recv_data = <span class=\"hljs-string\">b\'\'</span> <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(count):\r\n            data = self.socket.recv(<span class=\"hljs-number\">1024</span>)\r\n            recv_data += data\r\n        recv_data += self.socket.recv(gap_abs)\r\n\r\n        print(<span class=\"hljs-string\">\'recv data len is:\'</span>, len(recv_data)) <span class=\"hljs-keyword\">return</span> recv_data</pre>\r\n		<p>\r\n			3、继续思考，第6行尝试对接收到的头部二进制数据进行json解码，而头部二进制在服务器是通过UTF-8编码的，查看服务器端编码代码发现没有错误，所以编码错误被排除。剩下的应该就是接收的数据不完整问题。<br />\r\n4、按理说，通过struct和header来控制每一次读取的字节流可以保证每次收取的时候是准确完整的收取一个消息的数据，但是这里却发生了错误，我通过在下方的for函数增加print看一下依次循环读取时的长度数据：\r\n		</p>\r\n<pre class=\"python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(count):\r\n    data = self.socket.recv(<span class=\"hljs-number\">1024</span>)\r\n    print(<span class=\"hljs-string\">\'recv接收的长度是:\'</span>, len(data)) <span class=\"hljs-comment\"># 增加此行查看每次循环读取的长度是多少，按理应该是1024</span> recv_data += data</pre>\r\n		<p>\r\n			结果令我意外：\r\n		</p>\r\n<pre class=\"python\">recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">400</span> <span class=\"hljs-comment\"># 错误</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">400</span> <span class=\"hljs-comment\"># 错误</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">400</span> <span class=\"hljs-comment\"># 错误</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv data len <span class=\"hljs-keyword\">is</span>: <span class=\"hljs-number\">14121</span></pre>\r\n		<p>\r\n			按照逻辑，每一次循环应该都收取1024字节，却发现有3次收取并不完整（每次执行时错误不完全一样，但是都会发生错误），这就是导致最终数据不完整的原因。<br />\r\n因为执行tasklist返回的结果很长，导致接收数据不完整，于是下一条执行命令就发生了粘包，json解码的数据就不是一个正常的数据，故报错。\r\n		</p>\r\n		<h1 id=\"解决和总结\">\r\n			解决和总结\r\n		</h1>\r\n		<p>\r\n			1、之所以会发生这种情况，我猜测应该是recv函数的接收机制原因，recv函数一旦被调用，就会尝试获取缓冲中的数据，只要有数据，就会直接返回，如果缓冲中的数据大于1024，最多返回1024字节，不过如果缓冲只有400，也只会返回400，这是recv函数的读取机制。\r\n		</p>\r\n		<p>\r\n			2、当客户端需要读取大量数据（执行tasklist命令的返回就达到1w字节以上）时，需要多次recv，每一次recv时，客户端并不能保证缓冲中的数据量已经达到1024字节（这可能有服务器和客户端发送和接收速度不适配的问题），有可能某次缓冲只有400字节，但是recv依然读取并返回。\r\n		</p>\r\n		<p>\r\n			3、最初尝试解决的方法是，在recv之前增加time.sleep(0.1)来使得每次recv之前都有一个充足的时间来等待缓冲区的数据大于1024，此方法可以解决问题，不过这方法不是很好，因为如果服务器在远程，就很难控制sleep的秒数，因为你不知道网络IO会发生多长时间，一旦sleep时间过长，就会长期阻塞线程浪费cpu时间。\r\n		</p>\r\n		<p>\r\n			4、查看recv函数源码，发现是c写的，不过recv的接口好像除了size之外，还有一个flag参数。翻看《python参考手册》查找recv函数的说明，recv函数的flag参数可以有一个选项是：MSG_WAITALL，书上说，这表示在接收的时候，函数一定会等待接收到指定size之后才会返回。\r\n		</p>\r\n		<p>\r\n			5、最终使用如下方法解决：\r\n		</p>\r\n<pre class=\"python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(count): <span class=\"hljs-comment\"># time.sleep(0.1)</span> data = self.socket.recv(<span class=\"hljs-number\">1024</span>, socket.MSG_WAITALL)\r\n    print(<span class=\"hljs-string\">\'recv接收的长度是:\'</span>, len(data))\r\n    recv_data += data</pre>\r\n		<p>\r\n			接收结果：\r\n		</p>\r\n<pre class=\"python\">recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv接收的长度是: <span class=\"hljs-number\">1024</span> recv data len <span class=\"hljs-keyword\">is</span>: <span class=\"hljs-number\">16039</span></pre>\r\n		<p>\r\n			6、以后应该还会学习到更好的解决方法，努力学习。\r\n		</p>\r\n	</div>\r\n	<div id=\"MySignature\">\r\n	</div>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div id=\"blog_post_info_block\">\r\n		<br />\r\n	</div>\r\n</div>',1,0,0,1,1,'article_imgs/7.jpg',6),(8,'python异步编程--回调模型(selectors模块)','2018-11-04 16:09:31.190241','2018-11-04 16:09:31.190241','<div class=\"post\">\r\n	<h1 class=\"postTitle\">\r\n		<a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"https://www.cnblogs.com/zzzlw/p/9384308.html\">python异步编程--回调模型(selectors模块)</a> \r\n	</h1>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div class=\"postBody\">\r\n		<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n			<p class=\"toc\">\r\n				目录\r\n			</p>\r\n			<ul>\r\n				<li>\r\n					<a href=\"#参考地址\">0. 参考地址</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#前言\">1. 前言</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#核心类\">2. 核心类</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#selectselector核心函数代码分析\">3. SelectSelector核心函数代码分析</a> \r\n					<ul>\r\n						<li>\r\n							<a href=\"#注册\">3.1 注册</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#注销\">3.2 注销</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#查询\">3.3 查询</a> \r\n						</li>\r\n					</ul>\r\n				</li>\r\n				<li>\r\n					<a href=\"#别名\">4. 别名</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#总结\">5. 总结</a> \r\n				</li>\r\n				<li>\r\n					<a href=\"#代码报错问题\">6. 代码报错问题</a> \r\n					<ul>\r\n						<li>\r\n							<a href=\"#文件描述符数量\">1. 文件描述符数量</a> \r\n						</li>\r\n						<li>\r\n							<a href=\"#监听列表是否可以为空\">2. 监听列表是否可以为空</a> \r\n						</li>\r\n					</ul>\r\n				</li>\r\n				<li>\r\n					<a href=\"#关系图\">7. 关系图</a> \r\n				</li>\r\n			</ul>\r\n			<hr />\r\n			<h2 id=\"参考地址\">\r\n				0. 参考地址\r\n			</h2>\r\n			<p>\r\n				基本介绍 https://www.cnblogs.com/yinheyi/p/8127871.html<br />\r\n实验演示 https://www.cnblogs.com/xybaby/p/6406191.html#_label_2<br />\r\n详细讲解 http://aju.space/2017/07/31/Drive-into-python-asyncio-programming-part-1.html<br />\r\n官方文档selecotors https://docs.python.org/3/library/selectors.html<br />\r\n官方文档select https://docs.python.org/3/library/select.html\r\n			</p>\r\n			<h2 id=\"前言\">\r\n				1. 前言\r\n			</h2>\r\n			<p>\r\n				并发的解决方案中,因为阻塞IO调用的原因,同步模型(串行/多进程/多线程)并不适合大规模高并发.在非阻塞IO调用中,我们可以使用一个线程完成高并发的功能,不过因为非阻塞IO会立即返回,如何判断IO准备就绪以及就绪之后如何处理就变成了关键,所以我们需要附带额外的处理.\r\n			</p>\r\n			<p>\r\n				不论使用哪一种额外处理方式,核心都是为了获知IO准备就绪且执行对应的操作,额外处理方式之一就是回调+事件循环.\r\n			</p>\r\n			<p>\r\n				OS已经为我们提供了select/poll/epoll/kqueue等多种底层操作系统接口用以处理IO准备就绪的通知(即通过OS提供的接口可以方便的编写事件循环).而程序还需要完成:<strong>如何在IO准备就绪的时候执行预定的操作.</strong> \r\n			</p>\r\n			<p>\r\n				selecotrs模块,总代码611行,其中有5个类是同一个级别,只是根据OS的类型而有所不同.模块中还包含大量的注释,所以核心代码数量就在100行左右.selectors模块为我们提供了异步编程中的回调模型(后面还会写异步编程中的协程模型),所以我觉得对此模块的研究是很有必要的.\r\n			</p>\r\n			<h2 id=\"核心类\">\r\n				2. 核心类\r\n			</h2>\r\n			<p>\r\n				selectors模块中的核心类如下:<br />\r\n<img src=\"https://images2018.cnblogs.com/blog/1381809/201807/1381809-20180729094240015-564913257.jpg\" /> \r\n			</p>\r\n			<hr />\r\n			<p>\r\n				BaseSelector:是一个抽象基类,定义了核心子类的函数接口.BaseSelector类定义的核心接口如下:\r\n			</p>\r\n<pre class=\"python\"><span class=\"hljs-meta\">@abstractmethod</span> register(self, fileobj, events, data=<span class=\"hljs-keyword\">None</span>) <span class=\"hljs-comment\"># 提供文件对象的注册</span> <span class=\"hljs-meta\">@abstractmethod</span> unregister(self, fileobj) <span class=\"hljs-comment\"># 注销已注册的文件对象</span> <span class=\"hljs-meta\">@abstractmethod</span> select(self, timeout=<span class=\"hljs-keyword\">None</span>) <span class=\"hljs-comment\"># 向OS查询准备就绪的文件对象</span></pre>\r\n			<p>\r\n				其中,前两个函数封装了文件对象,并提供了data变量用于保存附加数据,这就提供了回调的环境.第三个函数select是对OS底层select/poll/epoll接口的封装,用以提供一个统一的对外接口.\r\n			</p>\r\n			<p>\r\n				_BaseSelectorImpl:是一个实现了register和unregister的基类,注意,此基类并没有实现select函数,因为select函数在不同OS上使用的底层接口不同,所以应该在对应的子类中定义\r\n			</p>\r\n			<p>\r\n				SelectSelector:使用windows时的接口<br />\r\nEpollSelector:使用linux时的接口(其他3个类相似,只是应用于不同的OS)<br />\r\nDefaultSelector:此为类别名,selectors模块会根据所在操作系统的类型,选择最优的接口\r\n			</p>\r\n			<p>\r\n				如下只对selectselector类的核心代码进行分析,其他对应类的代码逻辑基本一致.\r\n			</p>\r\n			<h2 id=\"selectselector核心函数代码分析\">\r\n				3. SelectSelector核心函数代码分析\r\n			</h2>\r\n			<p>\r\n				有名元祖selectorkey\r\n			</p>\r\n<pre class=\"python\">SelectorKey = namedtuple(<span class=\"hljs-string\">\'SelectorKey\'</span>, [<span class=\"hljs-string\">\'fileobj\'</span>, <span class=\"hljs-string\">\'fd\'</span>, <span class=\"hljs-string\">\'events\'</span>, <span class=\"hljs-string\">\'data\'</span>])</pre>\r\n			<p>\r\n				此对象是一个有名元祖,可以认为是对文件对象fileobj,对应的描述符值fd,对应的事件events,附带的数据data这几个属性的封装.<strong>此对象是核心操作对象</strong>,关联了需要监控的文件对象,关联了需要OS关注的事件,保存了附带数据(<em>其实这里就放的回调函数</em>)\r\n			</p>\r\n			<h3 id=\"注册\">\r\n				3.1 注册\r\n			</h3>\r\n<pre class=\"python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self)</span>:</span> super().__init__()\r\n    self._readers = set() <span class=\"hljs-comment\"># 使用集合处理唯一性</span> self._writers = set()</pre>\r\n			<p>\r\n				首先,构造函数中定义了_readers和_writers变量用于保存需要监听的文件对象的文件描述符值,并使用集合特性来处理唯一性.\r\n			</p>\r\n<pre class=\"python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">register</span><span class=\"hljs-params\">(self, fileobj, events, data=None)</span>:</span> key = super().register(fileobj, events, data) <span class=\"hljs-keyword\">if</span> events &amp; EVENT_READ:\r\n        self._readers.add(key.fd) <span class=\"hljs-keyword\">if</span> events &amp; EVENT_WRITE:\r\n        self._writers.add(key.fd) <span class=\"hljs-keyword\">return</span> key</pre>\r\n			<p>\r\n				一般我们使用register作为第一个操作的函数,代表着<strong>你需要监听的文件对象,以及,当它发生你关注的事件时,你要如何处理.</strong> \r\n			</p>\r\n			<p>\r\n				此函数有3个参数,分别是文件对象,监听事件(可读为1,可写为2),附带数据.<br />\r\nfileobj文件对象是类文件对象,与平台强相关,在windows上只能是socket,在linux上可以是任何linux支持的文件对象.<br />\r\nevents是一个int类型的值,就是EVENT_ERAD和EVENT_WRITE<br />\r\ndata是附带数据,我们可以把回调函数放在这里\r\n			</p>\r\n			<p>\r\n				此函数返回的key就是一个selectorkey有名元祖<br />\r\nregister函数将用户监听的文件对象和事件注册到有名元祖中,并加入监听集合_readers和_writers中\r\n			</p>\r\n			<h3 id=\"注销\">\r\n				3.2 注销\r\n			</h3>\r\n<pre class=\"python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">unregister</span><span class=\"hljs-params\">(self, fileobj)</span>:</span> key = super().unregister(fileobj)\r\n    self._readers.discard(key.fd)\r\n    self._writers.discard(key.fd) <span class=\"hljs-keyword\">return</span> key</pre>\r\n			<p>\r\n				当我们不需要监听某一个文件对象时,使用unregister注销它.这会使得它从_readers和_writers中被弹出.\r\n			</p>\r\n			<h3 id=\"查询\">\r\n				3.3 查询\r\n			</h3>\r\n<pre class=\"python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(self, timeout=None)</span>:</span> timeout = <span class=\"hljs-keyword\">None</span> <span class=\"hljs-keyword\">if</span> timeout <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">None</span> <span class=\"hljs-keyword\">else</span> max(timeout, <span class=\"hljs-number\">0</span>)\r\n    ready = [] <span class=\"hljs-keyword\">try</span>:\r\n        r, w, _ = self._select(self._readers, self._writers, [], timeout) <span class=\"hljs-keyword\">except</span> InterruptedError: <span class=\"hljs-keyword\">return</span> ready\r\n    r = set(r)\r\n    w = set(w) <span class=\"hljs-keyword\">for</span> fd <span class=\"hljs-keyword\">in</span> r | w:\r\n        events = <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">if</span> fd <span class=\"hljs-keyword\">in</span> r:\r\n            events |= EVENT_READ <span class=\"hljs-keyword\">if</span> fd <span class=\"hljs-keyword\">in</span> w:\r\n            events |= EVENT_WRITE\r\n\r\n        key = self._key_from_fd(fd) <span class=\"hljs-keyword\">if</span> key:\r\n            ready.append((key, events &amp; key.events)) <span class=\"hljs-keyword\">return</span> ready</pre>\r\n			<p>\r\n				这段代码描述了用户向OS发起的查询逻辑.select函数的timeout参数默认是None,这意味着默认情况下,如果没有任何一个就绪事件的发生,select调用会被永远阻塞.\r\n			</p>\r\n			<p>\r\n				select函数调用底层select/poll/epoll接口,此函数在SelectSelector类和EpollSelector类中的定义有所区别,会根据OS的类型调用对应接口,windows和linux实际调用的底层接口对比如下:\r\n			</p>\r\n<pre class=\"python\">用户统一调用高层select函数,此函数实际调用的接口为: <span class=\"hljs-comment\"># windows下使用select(SelectSelector类)</span> r, w, _ = self._select(self._readers, self._writers, [], timeout) <span class=\"hljs-comment\"># linux下使用epoll(EpollSelector类)</span> fd_event_list = self._epoll.poll(timeout, max_ev)</pre>\r\n			<p>\r\n				函数使用ready变量保存准备就绪的元祖(key, events)<br />\r\n在windows中,一旦底层select接口返回,会得到3个列表,前两个表示可读和可写的文件对象列表,并使用集合处理为唯一性.准备就绪的元祖对象会加入ready列表中返回.如果定义了timeout不为None,且发生了超时,会返回一个空列表.\r\n			</p>\r\n			<h2 id=\"别名\">\r\n				4. 别名\r\n			</h2>\r\n<pre class=\"python\"><span class=\"hljs-comment\"># Choose the best implementation, roughly:</span> <span class=\"hljs-comment\">#    epoll|kqueue|devpoll &gt; poll &gt; select.</span> <span class=\"hljs-comment\"># select() also can\'t accept a FD &gt; FD_SETSIZE (usually around 1024)</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">\'KqueueSelector\'</span> <span class=\"hljs-keyword\">in</span> globals():\r\n    DefaultSelector = KqueueSelector <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-string\">\'EpollSelector\'</span> <span class=\"hljs-keyword\">in</span> globals():\r\n    DefaultSelector = EpollSelector <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-string\">\'DevpollSelector\'</span> <span class=\"hljs-keyword\">in</span> globals():\r\n    DefaultSelector = DevpollSelector <span class=\"hljs-keyword\">elif</span> <span class=\"hljs-string\">\'PollSelector\'</span> <span class=\"hljs-keyword\">in</span> globals():\r\n    DefaultSelector = PollSelector <span class=\"hljs-keyword\">else</span>:\r\n    DefaultSelector = SelectSelector</pre>\r\n			<p>\r\n				selectors模块定义了一个别名DefaultSelector用于根据OS类型自动指向最优的接口类.\r\n			</p>\r\n			<h2 id=\"总结\">\r\n				5. 总结\r\n			</h2>\r\n			<p>\r\n				1 操作系统提供的select/poll/epoll接口可以用于<strong>编写事件循环</strong>,而selectors模块封装了select模块,select模块是一个低级别的模块,封装了select/poll/epoll/kqueue等接口.\r\n			</p>\r\n			<p>\r\n				2selectors模块中定义了有名元祖selectorkey,此对象封装了文件对象/描述符值/事件/附带数据,selectorkey为我们<strong>提供了回调的环境</strong> \r\n			</p>\r\n			<p>\r\n				3 使用selectors模块可以实现使用<strong>回调模型</strong>来完成高并发的方案.\r\n			</p>\r\n			<p>\r\n				4 <strong>(非常重要)</strong>异步回调模型,大部分事件和精力都是对回调函数的设计.<strong>回调模型使得每一个涉及IO操作的地方都需要单独分割出来作为函数,这会分割代码导致可读性下降和维护难度的上升.</strong> \r\n			</p>\r\n			<p>\r\n				5 回调函数之间的通信很困难,需要通过层层函数传递.\r\n			</p>\r\n			<p>\r\n				6 回调模型很难理解\r\n			</p>\r\n			<h2 id=\"代码报错问题\">\r\n				6. 代码报错问题\r\n			</h2>\r\n			<h3 id=\"文件描述符数量\">\r\n				1. 文件描述符数量\r\n			</h3>\r\n<pre class=\"python\">Traceback (most recent call last):\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/hello.py\"</span>, line <span class=\"hljs-number\">119</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;\r\n    loop()\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/hello.py\"</span>, line <span class=\"hljs-number\">102</span>, <span class=\"hljs-keyword\">in</span> loop\r\n    events = selector.select()\r\n  File <span class=\"hljs-string\">\"F:\\projects\\hello\\selectors.py\"</span>, line <span class=\"hljs-number\">323</span>, <span class=\"hljs-keyword\">in</span> select\r\n    r, w, _ = self._select(self._readers, self._writers, [], timeout)\r\n  File <span class=\"hljs-string\">\"F:\\projects\\hello\\selectors.py\"</span>, line <span class=\"hljs-number\">314</span>, <span class=\"hljs-keyword\">in</span> _select\r\n    r, w, x = select.select(r, w, w, timeout)\r\nValueError: too many file descriptors <span class=\"hljs-keyword\">in</span> select()</pre>\r\n			<p>\r\n				在windows上，底层使用的是select接口，可以支持的文件描述符数量理论说是1024，实际测试描述符必须小于512(我的电脑是win10 64bit)<br />\r\n在linux上使用的是epoll，可以支持大于1024的文件描述符数量，不过测试发现在达到4000左右的时候也会报错。\r\n			</p>\r\n			<p>\r\n				stack overflow解释1：https://stackoverflow.com/questions/31321127/too-many-file-descriptors-in-select-python-in-windows\r\n			</p>\r\n			<p>\r\n				stack overflow解释2：<br />\r\nhttps://stackoverflow.com/questions/47675410/python-asyncio-aiohttp-valueerror-too-many-file-descriptors-in-select-on-win\r\n			</p>\r\n			<h3 id=\"监听列表是否可以为空\">\r\n				2. 监听列表是否可以为空\r\n			</h3>\r\n<pre class=\"python\">Traceback (most recent call last):\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/world.py\"</span>, line <span class=\"hljs-number\">407</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;\r\n    loop()\r\n  File <span class=\"hljs-string\">\"F:/projects/hello/world.py\"</span>, line <span class=\"hljs-number\">378</span>, <span class=\"hljs-keyword\">in</span> loop\r\n    events = selector.select()\r\n  File <span class=\"hljs-string\">\"F:\\projects\\hello\\selectors.py\"</span>, line <span class=\"hljs-number\">323</span>, <span class=\"hljs-keyword\">in</span> select\r\n    r, w, _ = self._select(self._readers, self._writers, [], timeout)\r\n  File <span class=\"hljs-string\">\"F:\\projects\\hello\\selectors.py\"</span>, line <span class=\"hljs-number\">314</span>, <span class=\"hljs-keyword\">in</span> _select\r\n    r, w, x = select.select(r, w, w, timeout)\r\nOSError: [WinError <span class=\"hljs-number\">10022</span>] 提供了一个无效的参数。</pre>\r\n			<p>\r\n				在windows上，监听的文件对象列表不可以为空：\r\n			</p>\r\n			<p>\r\n				<img src=\"https://images2018.cnblogs.com/blog/1381809/201807/1381809-20180729123326291-961694719.png\" /> \r\n			</p>\r\n			<h2 id=\"关系图\">\r\n				7. 关系图\r\n			</h2>\r\n			<p>\r\n				<img src=\"https://images2018.cnblogs.com/blog/1381809/201807/1381809-20180729121124827-851681246.jpg\" /> \r\n			</p>\r\n		</div>\r\n		<div id=\"MySignature\">\r\n		</div>\r\n		<div class=\"clear\">\r\n		</div>\r\n<br />\r\n	</div>\r\n</div>',1,0,0,1,1,'article_imgs/8.jpg',4),(9,'RHCE认证考试','2018-11-04 16:10:41.377523','2018-11-04 16:10:41.377523','注意：本文件的解法基于老刘给的解法加上群里笑掌还有李国强版本的解法，仅做参考，我的考试是根据此文件做的。考官随机分配你的座位号，根据座位号你的网段不同如座位号14，即172.24.14.0/25网段，system1是服务器，system2是客户端，不需要处理主机名，已经配置好ip地址不用修改，root密码也会告诉你。本文件题目来自老刘的网页题目。<br />\r\n1、配置selinux模式<br />\r\n描述：SELinux 必须在两个系统system1和system2中运行于 Enforcing 模式<br />\r\n与rhcsa的方法一致，只不过RHCE需要针对system1和system2都要操作<br />\r\n<br />\r\n2、限制SSH访问：<br />\r\n描述：按以下要求配置SSH访问:<br />\r\n用户能够从域 domain1.example.com 内的客户端通过SSH远程访问您的两个虚拟机系统<br />\r\n在域 my133t.org 内的客户端不能访问您的两个虚拟机系统<br />\r\n防火墙有两类，基于TCP/IP报文防火墙(iptables和firewalld)和基于服务的高层防火墙TCP_Wrappers，两者都做，双重保险。<br />\r\n假设考试环境网段是172.25.1.0/24，不可信任域my133t.org网段是172.24.1.0/24<br />\r\nfirewall-cmd：<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp;&nbsp; &nbsp;--add-service=ssh&nbsp; --permanent<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --add-rich-rule \"rule family=ipv4 source address=172.24.1.0/24 service name=ssh reject\" --permanent<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --reload <br />\r\n&nbsp;&nbsp; &nbsp;防火墙加入ssh服务，默认所有人可访问，做一个富规则禁止来源是不可信任域的客户访问，重启防火墙使之生效。<br />\r\n&nbsp;&nbsp; &nbsp;注意：--permanent<br />\r\n&nbsp;&nbsp; &nbsp;通过firewall-cmd&nbsp; --list-all 查看配置的信息，systemctl&nbsp; restart/enable&nbsp; firewalld.service 保证服务重启加入启动项。<br />\r\n<br />\r\ntcp_wrappers：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; /etc/hosts.allow<br />\r\n&nbsp;&nbsp; &nbsp;sshd:172.25.1.0/255.255.255.0<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; /etc/hosts.deny<br />\r\n&nbsp;&nbsp; &nbsp;sshd:172.24.1.0/255.255.255.0<br />\r\n&nbsp;&nbsp; &nbsp;在hosts.allow文件写上允许的网段，在hosts.deny文件写上不信任域的网段，注意前面是服务名称<br />\r\n注意：考试的最开始就会告知域my1335.org的ip网段，建议tcp_wrapper和firewall-cmd都配置。<br />\r\n<br />\r\n3、配置ipv6地址<br />\r\n描述：在您的考试系统上配置接口 eth0 使用下列IPv6地址：<br />\r\nsystem1 上的地址应该是 2001:ac18::10a/64<br />\r\nsystem2 上的地址应该是 2001:ac18::114/64<br />\r\n两个系统必须能与网络 2001:ac18/64 内的系统通信。<br />\r\n地址必须在重启后依旧生效。<br />\r\n两个系统必须保持当前的IPv4地址并能通信。<br />\r\n在eth0上配置ipv6手工模式地址，使用ping6测试客户端和服务器的连通性，注意不要写错ipv6的地址<br />\r\n配置完ipv6依然要保持ipv4的连通性<br />\r\n注意：eth0接口默认就带了一个原始ipv6的地址，配置完本题地址会出现两个ipv6地址，不用担心。<br />\r\n<br />\r\n4、配置链路聚合<br />\r\n描述：在 system1.domain1.example.com 和 system2.domain1.example.com 之间按以下要求配置一个链路：<br />\r\n此链路使用接口 eth1 和 eth2<br />\r\n此链路在一个接口失效时仍然能工作<br />\r\n此链路在 system1 使用下面的地址 172.16.1.25/255.255.255.0<br />\r\n此链路在 system2 使用下面的地址 172.16.1.35/255.255.255.0<br />\r\n此链路在系统重启之后依然保持正常状态<br />\r\n<br />\r\n通过图形化来配置，注意config是{\"runner\":{\"name\":\"activebackup\"}}是一个json格式的配置<br />\r\n需要通过重启网络来测试一下team的连通性以及ipv4和 ipv6的连通性<br />\r\n注意：system1和system2都会给你3张网卡，eth 0,1,2，默认1和2是没有启动的，不用担心，通过图形化配置完team0之后就会自启动，注意配置team0的时候对于eth1和eth2要选择自启动（第一个标签页要打钩），本题做完建议把ipv4,ipv6,team0共计3个地址段都测试ping。<br />\r\n<br />\r\n5、自定义用户环境alias<br />\r\n描述：在系统 system1 和 system2上创建自定义命令名为 qstat 此自定义命令将执行以下命令:&nbsp;/bin/ps -Ao pid,tt,user,fname,rsz此命令对系统中所有用户有效。<br />\r\n使用/etc/bashrc文件配置alias命令别名，机器重启会自动生效<br />\r\nvim&nbsp; /etc/bashrc<br />\r\n在文件最后增加：alias&nbsp; qstat=\'/bin/ps&nbsp; -Ao pid,tt,user,fname,rsz\'&nbsp; 保存后source&nbsp; /etc/bashrc重新加载此文件验证qstat命令<br />\r\n注意使用单引号，不要使用双引号<br />\r\n注意：老刘给的网页和视频解法有错误，不用使用/etc/profile,要使用/etc/bashrc文件，在文件最后添加即可。<br />\r\n<br />\r\n6、配置本地邮件postfix服务<br />\r\n描述：在系统system1 和 system2 上 配置邮件服务，满足以下要求：<br />\r\n这些系统不接收外部发送来的邮件<br />\r\n在这些系统上本地发送的任何邮件都会自动路由到 rhgls.domain1.example.com<br />\r\n从这些系统上发送的邮件显示来自于 domain1.example.com<br />\r\n您可以通过发送邮件到本地用户 \'dave\' 来测试您的配置， 系统 rhgls.domain1.example.com 已经配置把此用户的邮件转到下列URL http://rhgls.domain1.example.com/received_mail/1<br />\r\n目前老师给出的解法和学员群里给出的解法有不同版本，待定解法版本<br />\r\n此处使用老刘的解法：<br />\r\n注意本题在system1和system2上都要操作。<br />\r\nyum&nbsp; -y&nbsp; install&nbsp; postfix<br />\r\nvim&nbsp; /etc/postfix/main.cf<br />\r\n在文件最后增加：<br />\r\n&nbsp;&nbsp; &nbsp;myorigin=example.com<br />\r\n&nbsp;&nbsp; &nbsp;relayhost=classroom.example.com<br />\r\n&nbsp;&nbsp; &nbsp;local_transport=error:local<br />\r\nsystemctl&nbsp; restart&nbsp; postfix<br />\r\nsystemctl&nbsp; enable&nbsp; postfix<br />\r\nfirewall-cmd&nbsp; --permanent&nbsp; --add-service=smtp<br />\r\nfirewall-cmd&nbsp; --reload<br />\r\n测试：mail&nbsp; -s&nbsp; test&nbsp; dave@desktop0.example.com,到题目给出的http地址查看是否有邮件<br />\r\n注意：首先，此题有多重解法版本，我使用此版本，只有3条配置命令。实际考试的时候无法mail&nbsp; -s&nbsp; test&nbsp; xxx 来测试，会一直卡着还得两次crtl + c才能退出邮件发送，此题我只完成配置，没有完成最后的验证，仅此参考。<br />\r\n<br />\r\n7、配置本地端口转发<br />\r\n描述：在系统system1配置端口转发，要求如下：在 172.24.1.0/24 网络中的系统，访问 system1 的本地端口 5423 将被转发到80 此设置必须永久有效<br />\r\n两种方式：<br />\r\n图形化：<br />\r\n&nbsp;&nbsp; &nbsp;firewall-config，选择permanent模式，配置forwarding port标签，注意tcp和udp都要配置，转发到本地local端口，最后reload，使用firewall-cmd&nbsp;&nbsp; --list-all&nbsp; 来验证配置信息<br />\r\n命令行：<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --permanent --add-forward-port=port=5423:proto=tcp:toport=80<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firewall-cmd --permanent --add-forward-port=port=5423:proto=udp:toport=80<br />\r\n&nbsp;&nbsp; &nbsp;最后firewall-cmd&nbsp; --reload，然后firewall-cmd&nbsp;&nbsp; --list-all验证<br />\r\n<br />\r\n8、通过smb共享目录<br />\r\n描述：在system1上配置SMB服务<br />\r\n您的 SMB 服务器必须是 STAFF 工作组的一个成员<br />\r\n共享 /common 目录 共享名必须为 common<br />\r\n只有 domain1.example.com 域内的客户端可以访问 common 共享<br />\r\ncommon 必须是可以浏览的<br />\r\n用户 andy 必须能够读取共享中的内容，如果需要的话，验证的密码是 flectrag<br />\r\n下载smb服务，yum&nbsp; -y&nbsp; install&nbsp; samba&nbsp; samba-client<br />\r\n创建/common目录并设置selinux上下文，后续共享名是[common], &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;semanage&nbsp; fcontext -a&nbsp; -t&nbsp; samba_share_t&nbsp; /common<br />\r\n&nbsp;&nbsp; &nbsp;restorecon&nbsp; -Rv&nbsp; /common<br />\r\n根据题目要求设置可以访问的用户及samba密码，如果未创建用户要先创建<br />\r\n&nbsp;&nbsp; &nbsp;useradd&nbsp; -s&nbsp; /sbin/nologin&nbsp; xxx<br />\r\n&nbsp;&nbsp; &nbsp;smbpasswd&nbsp; -a&nbsp; xxx ，根据题目要求配置samba密码<br />\r\n配置/etc/samba/smb.conf配置文件来完成题目要求的samba服务<br />\r\n&nbsp;&nbsp; &nbsp;[global]<br />\r\n&nbsp;&nbsp; &nbsp;workgroup = STAFF<br />\r\n&nbsp;&nbsp; &nbsp;[common]<br />\r\n&nbsp;&nbsp; &nbsp;path = /common<br />\r\n&nbsp;&nbsp; &nbsp;hosts allow = 172.25.0.&nbsp; 访问控制，允许访问的域<br />\r\n&nbsp;&nbsp; &nbsp;browseable = yes&nbsp; 可以被浏览<br />\r\n设置防火墙<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --permanent --add-service=samba<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --permanent --add-service=mountd<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --reload<br />\r\n重启服务并加入启动项<br />\r\n&nbsp;&nbsp; &nbsp;systemctl restart&nbsp; smb&nbsp; nmb<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable&nbsp; smb&nbsp; nmb<br />\r\n客户端测试：<br />\r\n&nbsp;&nbsp; &nbsp;yum&nbsp; -y install&nbsp; samba-client&nbsp; cifs-utils<br />\r\n&nbsp;&nbsp; &nbsp;smbclient&nbsp; -L&nbsp; //服务器ip&nbsp;&nbsp; -U&nbsp; 之前创建的访问用户<br />\r\n&nbsp;&nbsp; &nbsp;也可以尝试这样测试：mount&nbsp; -t cifs&nbsp; -o&nbsp; username=andy,password=flectrag&nbsp;&nbsp; //172.25.0.11/common&nbsp;&nbsp; /mnt，成功挂载后，进入mnt目录创建一个文件应该要被拒绝，然后卸载mnt目录<br />\r\n注意：建议有时间的话在客户端上做mount测试。<br />\r\n<br />\r\n9、配置smb共享目录并提供多用户挂载(只读+读写)<br />\r\n描述：在system1 共享通过SMB目录 /miscellaneous 满足以下要求：<br />\r\n共享名为 miscellaneous<br />\r\n共享目录 miscellaneous 只能被 domain1.example.com 域中的客户端使用<br />\r\n共享目录 miscellaneous 必须可以被浏览<br />\r\n用户 silene 必须能以读的方式访问此共享， 访问密码是 flectrag<br />\r\n用户 akira 必须能以读写的方式访问此共享， 访问密码是 flectrag<br />\r\n此共享永久挂载在 system2.domain1.example.com 上的 /mnt/multi 目录, 并使用用户 silene 作为认证<br />\r\n任何用户可以通过用户 akira 来临时获取写的权限<br />\r\n一个用户以只读方式，一个用户以读写方式，注意，默认samba提供目录共享的时候就是只读方式，如果要读写，需要在共享目录配置中增加write list = xxx<br />\r\n配置共享目录：<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp; /devops<br />\r\n&nbsp;&nbsp; &nbsp;chmod&nbsp; a+w&nbsp; /devops ， 创建共享目录并配置可写权限<br />\r\n&nbsp;&nbsp; &nbsp;semanage&nbsp; fcontext&nbsp; -a -t&nbsp; samba_share_t&nbsp;&nbsp; /devops<br />\r\n&nbsp;&nbsp; &nbsp;retorecon -Rv&nbsp; /devops<br />\r\n配置多用户登录信息：<br />\r\n&nbsp;&nbsp; &nbsp;useradd&nbsp; -s&nbsp; /sbin/nologin&nbsp;&nbsp; rob<br />\r\n&nbsp;&nbsp; &nbsp;useradd -s&nbsp; /sbin/nologin&nbsp; brain<br />\r\n&nbsp;&nbsp; &nbsp;smbpasswd&nbsp; -a rob<br />\r\n&nbsp;&nbsp; &nbsp;smbpasswd -a brain<br />\r\n配置samba服务：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; /etc/samba/smb.conf<br />\r\n&nbsp;&nbsp; &nbsp;[devops]<br />\r\n&nbsp;&nbsp; &nbsp;path = /devops<br />\r\n&nbsp;&nbsp; &nbsp;hosts allow = 172.25.0.<br />\r\n&nbsp;&nbsp; &nbsp;browseable = yes<br />\r\n&nbsp;&nbsp; &nbsp;writable = no<br />\r\n&nbsp;&nbsp; &nbsp;write&nbsp; list = brain<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp; restart&nbsp; smb&nbsp; nmb<br />\r\n客户端配置：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; /etc/fstab<br />\r\n&nbsp;&nbsp; &nbsp;以rob用户的只读方式永久挂载到/mnt/multi目录<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp; /mnt/multi<br />\r\n&nbsp;&nbsp; &nbsp;//172.25.0.11/devops&nbsp;&nbsp;&nbsp; /mnt/multi&nbsp; cifs&nbsp;&nbsp; defaults,multiuser,username=rob,password=redhat,sec=ntlmssp&nbsp;&nbsp; 0 0<br />\r\n&nbsp;&nbsp; &nbsp;mount&nbsp; -a <br />\r\n&nbsp;&nbsp; &nbsp;此时/mnt/multi目录是无法创建新文件的<br />\r\n&nbsp;&nbsp; &nbsp;测试：使用brain用户挂载到一个测试目录，可以发现是允许创建新文件的<br />\r\n注意：此题目的sliene和akira等同于解法中的rob和brain。<br />\r\n<br />\r\n10、配置nfs服务，提供两个目录远程共享<br />\r\n描述：在 system1 配置NFS服务，要求如下:<br />\r\n以只读的方式共享目录 /public 同时只能被 domain1.example.com 域中的系统访问<br />\r\n以读写的方式共享目录 /protected 能被 domain1.example.com 域中的系统访问<br />\r\n访问 /protected 需要通过Kerberos安全加密， 您可以使用下面URL提供的密钥 http://host.domain1.example.com/materials/nfs_server.keytab<br />\r\n目录 /protected 应该包含名为 confidential 拥有人为deepak 的子目录<br />\r\n用户 deepak 能以读写方式访问 /protected/confidential<br />\r\n/public，只读，<br />\r\n/protected，读写，需要krb5p安全加密<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;确保时间与classroom一致(有些解法里没有这一步)<br />\r\n&nbsp;&nbsp; &nbsp;配置/etc/chrony.conf<br />\r\n&nbsp;&nbsp; &nbsp;确认nfs已安装，yum&nbsp; list&nbsp; nfs*<br />\r\n目录配置：<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp; /public<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp; -p&nbsp; /protected/project&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;useradd&nbsp; ldapuser0<br />\r\n&nbsp;&nbsp; &nbsp;chown&nbsp; -R ldapuser0&nbsp; /protected/project<br />\r\n&nbsp;&nbsp; &nbsp;(待定：后续用户要通过加密的方式进入/protected/project目录创建文件，考虑是否需要chmod&nbsp; -R&nbsp; o+w /protected，注意：该待定在我考试的时候使用的是setfacl&nbsp; -m&nbsp; u:用户名:rwx&nbsp;&nbsp; 目录来设置的)<br />\r\nnfs服务配置：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; /etc/exports<br />\r\n&nbsp;&nbsp; &nbsp;/public&nbsp;&nbsp;&nbsp; 172.25.0.0/24(sync,ro,sec=sys)<br />\r\n&nbsp;&nbsp; &nbsp;/protected&nbsp;&nbsp; 172.25.0.0/24(sync,rw,sec=krb5p)<br />\r\n启用版本-V 4.2：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp;&nbsp; /etc/sysconfig/nfs<br />\r\n&nbsp;&nbsp; &nbsp;RPCNFSDARGS=\'-V 4.2\'<br />\r\n下载服务器端证书：<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp;&nbsp; -O&nbsp;&nbsp; /etc/krb5.keytab&nbsp;&nbsp;&nbsp; 服务器证书http地址<br />\r\n防火墙配置：<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --permanent&nbsp; --add-service=nfs<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --permanent&nbsp; --add-service=rpc-bind<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --permanent&nbsp; --add-service=mountd<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --reload<br />\r\n重启服务，加入启动项：<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp; restart&nbsp; nfs-server<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart nfs-secure-server<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp; enable&nbsp; nfs-server<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable&nbsp; nfs-secure-server<br />\r\n注意：此题的deepak等同于解法中的ldapuser0<br />\r\n<br />\r\n11、客户端配置nfs挂载<br />\r\n描述：在 system2 上挂载一个来自 system1.domain1.example.com 的NFS共享， 并符合下列要求：<br />\r\n/public 挂载在下面的目录上 /mnt/nfsmount<br />\r\n/protected 挂载在下面的目录上 /mnt/nfssecure 并使用安全的方式，密钥下载URL如下： http://host.domain1.example.com/materials/nfs_client.keytab<br />\r\n用户 deepak 能够在 /mnt/nfssecure/confidential 上创建文件<br />\r\n这些文件系统在系统启动时自动挂载<br />\r\n创建两个挂载点，分别挂载上一题的/public 和 /protected<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;确保时间与classroom一致(有些解法里没有这一步)<br />\r\n&nbsp;&nbsp; &nbsp;配置/etc/chrony.conf<br />\r\n&nbsp;&nbsp; &nbsp;确认nfs已安装，yum&nbsp; list&nbsp; nfs*<br />\r\n目录配置：<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp; /mnt/nfsmount<br />\r\n&nbsp;&nbsp; &nbsp;mkdir /mnt/nfssecure<br />\r\n下载客户端证书：<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp;&nbsp; -O&nbsp;&nbsp; /etc/krb5.keytab&nbsp;&nbsp;&nbsp; 客户端证书http地址<br />\r\n设置自动挂载：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; /etc/fstab<br />\r\n&nbsp;&nbsp; &nbsp;172.25.0.11:/public&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /mnt/nfsmount&nbsp;&nbsp; nfs&nbsp; defaults,sec=sys&nbsp; 0 0<br />\r\n&nbsp;&nbsp; &nbsp;172.25.0.11:/protected&nbsp;&nbsp; /mnt/nfssecure&nbsp; nfs&nbsp; defaults,sec=krb5p,v4.2&nbsp;&nbsp; 0 0<br />\r\n&nbsp;&nbsp; &nbsp;mount&nbsp; -a <br />\r\n启动客户端nfs-secure服务：<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart&nbsp; nfs-secure<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable&nbsp; nfs-secure<br />\r\n(目前/protected在客户端上无法挂载log提示验证错误：)<br />\r\n&nbsp;<br />\r\n注意：此题在老刘给的模拟环境是无法挂载protected，但是可以挂载public，有朋友偶尔可以挂载protected，但是大部分都不行，但是根据此解法，考试的时候protected是可以挂载上的。<br />\r\n<br />\r\n12、配置一个基本的http服务器(所有http题目都要注意文本命令不要输错)<br />\r\n描述：在 system1 上配置一个站点 http://system1.domain1.example.com 然后执行下述步骤：<br />\r\n从 http://rhgls.domain1.example.com/materials/station.html&nbsp;下载文件，并且将文件重命名为 index.html 不要修改此文件的内容<br />\r\n将文件 index.html 拷贝到您的 web 服务器的 DocumentRoot 目录下<br />\r\n来自于 domain1.example.com 域的客户端可以访问此Web服务<br />\r\n来自于 my133t.org 域的客户端拒绝访问此Web服务<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;yum&nbsp; -y install httpd<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart&nbsp; httpd<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable httpd&nbsp;&nbsp; &nbsp;<br />\r\n服务配置：<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp; /etc/httpd/conf.d&nbsp; , 进入该目录，5题的http的配置文件都写在这个文件中，这5个文件可以写在一个文件也可以分开5个文件写(如果题目有要求不同文件的话)<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp;&nbsp; vhost-server0.conf<br />\r\n&nbsp;&nbsp; &nbsp;&lt;virtualhost&nbsp; *:80&gt;<br />\r\n&nbsp;&nbsp; &nbsp;documentroot&nbsp; \"/var/www/html\"&nbsp;&nbsp;&nbsp;&nbsp; 使用默认的目录，13题基于https的服务也使用该目录<br />\r\n&nbsp;&nbsp; &nbsp;servername&nbsp;&nbsp; server0.example.com&nbsp;&nbsp;&nbsp;&nbsp; 这个是访问本题的网址，该域名应该要能被system1,system2,物理机ping通<br />\r\n&nbsp;&nbsp; &nbsp;&lt;/virtualhost&gt;<br />\r\n<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp;&nbsp; /var/www/html<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp;&nbsp; -O&nbsp; index.html&nbsp;&nbsp; http://xxxxxxx&nbsp;&nbsp; 下载题目给出的网址并重命名成index.html<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart&nbsp; httpd<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --permanet&nbsp; --add-service=http<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --permanet --add-rich-rule&nbsp; \"rule&nbsp; family=ipv4&nbsp; source&nbsp; address=172.17.10.0/24&nbsp; service&nbsp; name=http&nbsp; reject\"&nbsp;&nbsp;&nbsp; 把不可信任域加入富规则<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp;&nbsp; --reload<br />\r\n测试：可以使用firefox浏览器测试，也可以curl&nbsp;&nbsp; http://server0.example.com来测试<br />\r\n注意：没有要求新建html数据目录的话，建议使用默认的/var/www/html目录，http的5题可以使用不同的虚拟配置文件，只要放在/etc/httpd/conf.d/目录中，后缀必须是.conf文件即可。<br />\r\n<br />\r\n13、配置安全web服务<br />\r\n描述：为站点 http://system1.domain1.example.com 配置TLS加密 一个已签名证书从 http://host.domain1.example.com/materials/system1.crt 获取 此证书的密钥从 http://host.domain1.example.com/materials/system1.key 获取 此证书的签名授权信息从 http://host.domain1.example.com/materials/domain1.crt 获取<br />\r\n该服务基于12题，即12题的页面要通过https的方式访问，内容不变，故13题使用的html目录和12题一样，都是/var/www/html，3个认证文件也下载到此目录<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;yum&nbsp; -y install&nbsp; mod_ssl<br />\r\n&nbsp;&nbsp; &nbsp;要下载的用于https认证文件有3个：server0.key&nbsp; server0.crt&nbsp;&nbsp; example-ca.crt<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp; /var/www/html<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp; http://xxxxxxx<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp; http://xxxxxxx<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp; http://xxxxxxx----下载3个认证文件到该目录<br />\r\n<br />\r\n服务配置：<br />\r\n&nbsp;&nbsp; &nbsp;/etc/httpd/conf.d目录中的ssl.conf中的配置可以使用<br />\r\n&nbsp;&nbsp; &nbsp; <br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart&nbsp; httpd<br />\r\n验证：在firefox上验证https://server0.example.com ， 需要点击知晓risk然后下载证书即可查看server0.example.com的页面内容<br />\r\n注意：此题我考试的时候没有考，解法注意安装mod_ssl，装了这个模块就能找到/etc/httpd/conf.d/ssl.conf，这个文件有所有ssl的命令，共计7条SSL开头的命令，加上servername和documentroot共计9条。<br />\r\n<br />\r\n14、配置虚拟主机http服务<br />\r\n描述：在 system1 上扩展您的 web 服务器，为站点 http://www.domain1.example.com创建一个虚拟主机，然后执行下述步骤：<br />\r\n设置 DocumentRoot 为 /var/www/virtual<br />\r\n从 http://rhgls.domain1.example.com/materials/www.html<br />\r\n下载文件并重命名为 index.html 不要对文件 index.html 的内容做任何修改<br />\r\n将文件 index.html 放到虚拟主机的 DocumentRoot 目录下<br />\r\n确保 andy 用户能够在 /var/www/virtual 目录下创建文件<br />\r\n注意：原始站点 http://system1.domain1.example.com 必须仍然能够访问， 名称服务器 domain1.example.com 提供对主机名 www.domain1.example.com 的域名解析<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp;&nbsp; /var/www/virtual&nbsp; 根据题目要求要新建一个html数据目录<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp;&nbsp; /var/www/virtual<br />\r\n&nbsp;&nbsp; &nbsp;useradd&nbsp; floyd<br />\r\n&nbsp;&nbsp; &nbsp;setfacl&nbsp; -m&nbsp; -u:floyd:rwx&nbsp;&nbsp; /var/www/virtual/&nbsp; 将该用户在该目录创建一个facl<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp; -O&nbsp; index.html&nbsp;&nbsp; http://xxxxxx<br />\r\n服务配置：<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp; /etc/httpd/conf.d<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; vhost-www0.conf<br />\r\n&nbsp;&nbsp; &nbsp;&lt;virtualhost&nbsp; *:80&gt;<br />\r\n&nbsp;&nbsp; &nbsp;documentroot&nbsp; \"/var/www/virtual\"<br />\r\n&nbsp;&nbsp; &nbsp;servername&nbsp; www0.example.com<br />\r\n&nbsp;&nbsp; &nbsp;&lt;/virtualhost&gt;<br />\r\n<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart&nbsp; httpd<br />\r\n验证：通过浏览器或者curl&nbsp;&nbsp; http://www0.example.com<br />\r\n注意：这题很简单，没啥注意的，就是不要有拼写错误。<br />\r\n<br />\r\n15、配置web内容的访问控制<br />\r\n描述：在您的system1 上的 web 服务器的 DocumentRoot 目录下 创建一个名为 secret 的目录，要求如下：<br />\r\n从 http://rhgls.domain1.example.com/materials/private.html 下载一个文件副本到这个目录，并且重命名为 index.html。<br />\r\n不要对这个文件的内容做任何修改。<br />\r\n从 system1 上，任何人都可以浏览 secret 的内容， 但是从其它系统不能访问这个目录的内容<br />\r\n其实本题就是在14题的基础上，在/var/www/virtual目录下创建private 目录，针对private目录做访问控制，因为是基于14题，所以配置也在14题的文件中<br />\r\nmkdir&nbsp;&nbsp; /var/www/virtual/private<br />\r\ncd&nbsp;&nbsp; /var/www/virtual/private<br />\r\nwget&nbsp; -O&nbsp; index.html&nbsp;&nbsp; http://xxxxxxxxx<br />\r\n<br />\r\ncd&nbsp;&nbsp; /etc/httpd/conf.d<br />\r\nvim&nbsp; vhost-www0.conf<br />\r\n&lt;virtualhost&nbsp; *:80&gt;<br />\r\ndocumentroot&nbsp; \"/var/www/virtual\"<br />\r\nservername&nbsp; www0.example.com<br />\r\n&lt;directory \"/var/www/virtual/private\"&gt; ---增加的红色部分即为针对private目录的访问控制<br />\r\nallowoverride none<br />\r\nrequire&nbsp; local<br />\r\nrequire&nbsp;&nbsp; all&nbsp;&nbsp; denied<br />\r\n&lt;/directory&gt;<br />\r\n&lt;/virtualhost&gt;<br />\r\nsystemctl&nbsp; restart&nbsp; httpd<br />\r\n验证：在system1上可以打开网页http://www0.example.com/private/&nbsp; , 在system2和物理机都打不开，但是www0.example.com都可以打开<br />\r\n注意：此题如果没有说明针对哪一个域名增加子目录，建议在两个域名基础上都建立子目录。<br />\r\n<br />\r\n16、配置动态web<br />\r\n描述：在 system1 上配置提供动态Web内容，要求如下：<br />\r\n动态内容由名为dynamic.domain1.example.com的虚拟主机提供<br />\r\n虚拟主机侦听在端口 8998<br />\r\n从 http://rhgls.domain1.example.com/materials/webapp.wsgi 下载一个脚本，然后放在适当的位置， 无论如何不要求修改此文件的内容<br />\r\n客户端访问 http://dynamic.domain1.example.com:8998/ 时 应该接收到动态生成的web页面<br />\r\n此 http://dynamic.domain1.example.com:8998/ 必须能被 domain1.example.com 域内的所有系统访问<br />\r\n注意：老刘给的模拟环境，webapp.wsgi文件在桌面RHCE文件夹中，复制到system1后需要更改selinux上下文-&gt;和/var/www/server0/index.html的一样<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;yum&nbsp; -y&nbsp; install&nbsp; mod_wsgi<br />\r\n&nbsp;&nbsp; &nbsp;mkdir&nbsp; /var/www/webapp&nbsp; ，创建一个文件夹放置动态脚本<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp;&nbsp; /var/www/webapp<br />\r\n&nbsp;&nbsp; &nbsp;wget&nbsp;&nbsp; http://xxxxxxxx ， 从题目给的地址下载动态脚本，如果用老刘的模拟环境，看上面的注意<br />\r\n服务配置：<br />\r\n&nbsp;&nbsp; &nbsp;semanage&nbsp; port&nbsp; -a -t http_port_t&nbsp; -p&nbsp; tcp&nbsp; 8908<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --permanet&nbsp; --add-port=8908/tcp<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --reload<br />\r\n<br />\r\n&nbsp;&nbsp; &nbsp;cd&nbsp;&nbsp; /etc/httpd/conf.d<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp; webapp0.conf<br />\r\n&nbsp;&nbsp; &nbsp;listen 8908<br />\r\n&nbsp;&nbsp; &nbsp;&lt;virtualhost&nbsp; *:8908&gt;<br />\r\n&nbsp;&nbsp; &nbsp;servername&nbsp; webapp0.example.com<br />\r\n&nbsp;&nbsp; &nbsp;wsgiscriptalias&nbsp; /&nbsp; /var/www/webapp/脚本名称<br />\r\n&nbsp;&nbsp; &nbsp;&lt;/virtualhost&gt;<br />\r\n<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp; restart&nbsp; httpd<br />\r\n验证：curl&nbsp; http://xxxxxx:8908&nbsp; 或者浏览器 ，注意访问地址后面加:8908<br />\r\n注意：如果不安装mod_wsgi是会提示wsgiscriptalias命令无法识别的。遇到错误通过journalist&nbsp; -xn查看说明。<br />\r\n<br />\r\n17、创建一个foo/bar脚本<br />\r\n描述：在system1上创建一个名为 /root/script 的脚本， 让其提供下列特性：<br />\r\n当运行 /root/script foo，输出为 bar<br />\r\n当运行 /root/script bar，输出为 foo<br />\r\n当没有任何参数或者参数不是 foo 或者 bar时， 其错误输出产生以下的信息：<br />\r\n/root/script foo|bar<br />\r\n通过case命令语句和$1代表第一个参数来编写，注意脚本文件要chmod a+x&nbsp; 脚本文件<br />\r\n&nbsp;<br />\r\n<br />\r\n18、创建一个添加用户的脚本<br />\r\n描述：在 system1 上创建一个脚本，名为 /root/mkusers , 此脚本能实现为系统 system1 创建本地用户, 并且这些用户 的用户名来自一个包含用户名列表的文件。同时满足下列要求：<br />\r\n此脚本要求提供一个参数，此参数就是包含用户名列表的文件<br />\r\n如果没有提供参数，此脚本应该给出下面的提示信息 Usage: /root/mkusers userfile 然后退出并返回相应的值<br />\r\n如果提供一个不存在的文件名，此脚本应该给出下面的提示信息 Input file not found 然后退出并返回相应的值<br />\r\n创建的用户登录shell为 /bin/false<br />\r\n此脚本不需要为用户设置密码<br />\r\n您可以从下面的URL获取用户名列表作为测试用 http://rhgls.domain1.example.com/materials/userlist<br />\r\n$#代表输入的参数个数，!&nbsp; -f&nbsp; $1 代表测试输入的文件不存在，最后读取文件每一行并创建用户，可能需要批量设置这些用户的密码<br />\r\n&nbsp;<br />\r\n注意：我没考此题，不做说明。<br />\r\n<br />\r\n19、配置iscsi服务器<br />\r\n描述：配置 system1 提供一个 iSCSI 服务 磁盘名为 iqn.2014-12.com.example.domain1:system1 ，并符合下列要求：<br />\r\n服务端口为 3260<br />\r\n使用 iscsi_vol 作其后端卷 其大小为 3G<br />\r\n此服务只能被 system2.domain1.example.com 访问<br />\r\n从服务器上获取一块lvm逻辑卷3G，通过iscsi远程提供iscsi服务<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;fdisk&nbsp; /dev/xxx<br />\r\n&nbsp;&nbsp; &nbsp;pvcreate,vgcreate,lvcreate&nbsp; -n&nbsp; xxx -L 3G&nbsp; vg名称，按题目要求创建lvm，注意名称要求<br />\r\n服务配置：<br />\r\n&nbsp;&nbsp; &nbsp;yum -y install targetd&nbsp; targetcli ,&nbsp; targetd是服务端，targetcli是交互式配置工具<br />\r\n&nbsp;&nbsp; &nbsp;targetcli, 配置backstore里面的block<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 配置iscsi里面的iqn.xxxxxx，里面tpg1目录下的3个目录都要配置：<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;acls , 是访问控制，注意客户端要和这个完全一致，否则会验证错误<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;luns, 将上面的/backtore/block/xxx 加入<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;portals,启动服务器ip地址的监听，默认端口3260，后续firewall要开通该端口<br />\r\n&nbsp;&nbsp; &nbsp; <br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --permanent&nbsp; --add-port=3260/tcp<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --reload<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart&nbsp; targetd<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp; enable&nbsp; targetd<br />\r\n注意：我的截图是做了两个iscsi所以有两个block文件请忽略其中一个无关的。<br />\r\n<br />\r\n20、配置iscsi客户端<br />\r\n描述：配置 system2 使其能连接 在 system1 的上提供的 iqn.2014-12.com.example.domain1:system1 并符合以下要求：<br />\r\niSCSI 设备在系统启动的期间自动加载<br />\r\n块设备 iSCSI 上包含一个大小为 1700 MiB 的分区，并格式化为 xfs<br />\r\n此分区挂载在 /mnt/data 上 同时在系统启动的期间自动挂载<br />\r\n前置配置：<br />\r\n&nbsp;&nbsp; &nbsp;yum&nbsp; -y&nbsp; install&nbsp; iscsi-initiator-utils , 可以使用yum&nbsp; -y&nbsp; install&nbsp; iscsi*<br />\r\n客户端配置：<br />\r\n&nbsp;&nbsp; &nbsp;vim&nbsp;&nbsp; /etc/iscsi/initiatorname.iscsi<br />\r\n&nbsp;&nbsp; &nbsp;配置名称和上一题服务器targetcli里的acls名称要一致<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp; restart&nbsp; iscsi<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp;&nbsp;&nbsp; restart&nbsp; iscsid<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable&nbsp; iscsi<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable iscsid<br />\r\n发现+登录：<br />\r\n&nbsp;&nbsp; &nbsp;iscsiadm&nbsp; -m&nbsp; discovery&nbsp; -t&nbsp; st -p&nbsp; 服务器ip<br />\r\n&nbsp;&nbsp; &nbsp;可以看到返回的服务器提供的iscsi服务信息<br />\r\n&nbsp;&nbsp; &nbsp;iscsiadm&nbsp;&nbsp; -m&nbsp; node&nbsp; -T&nbsp;&nbsp; iqn.xxxxx(上面提供的信息)&nbsp; -l&nbsp; (注意，-l表示登录，-u表示登出)<br />\r\n&nbsp;&nbsp; &nbsp;显示登录success<br />\r\n分区+挂载：<br />\r\n&nbsp;&nbsp; &nbsp;通过lsblk可以看到多了硬盘设备,一般是/dev/sda,确认容量大小和服务器上给出的是一致的<br />\r\n&nbsp;&nbsp; &nbsp;fdisk&nbsp; 该设备，按照题目要求分出相应大小的区，并mkfs.xxx格式化<br />\r\n&nbsp;&nbsp; &nbsp;通过/etc/fstab挂载，使用UUID=xxxx&nbsp;&nbsp;&nbsp;&nbsp; /mnt/data&nbsp;&nbsp;&nbsp; xfs或者ext4&nbsp;&nbsp;&nbsp; defaults,_netdev&nbsp;&nbsp; 0 0 的方式&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;mount&nbsp; -a<br />\r\n注意：使用UUID的方式挂载。<br />\r\n<br />\r\n21、安装mariadb服务<br />\r\n描述：在 system1 上创建一个 MariaDB 数据库, 名为 Contacts ，并符合以下条件：<br />\r\n数据库应该包含来自数据库复制的内容，复制文件的URL为 http://rhgls.domain1.example.com/materials/users.mdb 。<br />\r\n数据库只能被 localhost 访问。<br />\r\n除了root用户, 此数据库只能被用户 Luigi 查询。 此用户密码为 flectrag 。<br />\r\nroot 用户的密码为 flectrag ， 同时不允许空密码登录。<br />\r\n前置安装：<br />\r\n&nbsp;&nbsp; &nbsp;yum&nbsp; -y&nbsp; install&nbsp; mariadb* &nbsp;<br />\r\n开启防火墙：<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd&nbsp; --perment --add-service=mysql<br />\r\n&nbsp;&nbsp; &nbsp;firewall-cmd --reload<br />\r\n重启服务，加入启动项：<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; restart mariadb<br />\r\n&nbsp;&nbsp; &nbsp;systemctl&nbsp; enable mariadb<br />\r\n初始化数据库：<br />\r\n&nbsp;&nbsp; &nbsp;mysql_secure_installation<br />\r\n&nbsp;&nbsp; &nbsp;空，根据题目设置root密码，移除匿名用户，删除test库，禁止远程登录，立即生效<br />\r\n创建数据库并导入：<br />\r\n&nbsp;&nbsp; &nbsp;mysql&nbsp; -u root -p<br />\r\n&nbsp;&nbsp; &nbsp;使用之前设置的密码登录<br />\r\n&nbsp;&nbsp; &nbsp;showdatabases;<br />\r\n&nbsp;&nbsp; &nbsp;create&nbsp; database&nbsp; 数据库名称;<br />\r\n&nbsp;&nbsp; &nbsp;use&nbsp;&nbsp; 数据库名称;<br />\r\n&nbsp;&nbsp; &nbsp;show tables;<br />\r\n&nbsp;&nbsp; &nbsp;source&nbsp;&nbsp; /root/xxx;&nbsp;&nbsp; 将某一个数据库dump文件载入该数据库生成tables<br />\r\n&nbsp;&nbsp; &nbsp;show&nbsp; tables; 验证<br />\r\n配置新建数据库账户和权限设置：<br />\r\n&nbsp;&nbsp; &nbsp;create&nbsp; user&nbsp; mary@\'localhost\'&nbsp;&nbsp; identified&nbsp; by \'mary_password\';<br />\r\n&nbsp;&nbsp; &nbsp;create&nbsp; user&nbsp; legacy@\'localhost\'&nbsp; identified&nbsp; by \'legacy_password\';<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;grant&nbsp; select&nbsp; on&nbsp; 数据库.*&nbsp;&nbsp; to&nbsp; mary@\'localhost\';<br />\r\n&nbsp;&nbsp; &nbsp;grant&nbsp; select,insert,update,delete&nbsp; on&nbsp; 数据库.某一个表单&nbsp;&nbsp; to&nbsp; legacy@\'localhost\';<br />\r\n<br />\r\n&nbsp;&nbsp; &nbsp;show&nbsp; grants&nbsp; for&nbsp; mary@\'localhost\';&nbsp; 查看该用户的权限<br />\r\n&nbsp;&nbsp; &nbsp;revoke&nbsp; select&nbsp; on&nbsp; 数据库.*&nbsp;&nbsp; from&nbsp; mary@\'localhost\';&nbsp; 移除某一个用户对于某一个数据库.*&nbsp; 的select权限<br />\r\n<br />\r\n22、数据库查询<br />\r\n此题的题目根据实际情况灵活处理，题目基本都是单表和双表查询。<br />\r\n&nbsp;&nbsp; &nbsp;desc&nbsp; 某一个table;&nbsp;&nbsp; 查看某一个table表单的描述<br />\r\n&nbsp;&nbsp; &nbsp;select&nbsp; *&nbsp;&nbsp; from&nbsp;&nbsp; 表单;&nbsp;&nbsp; 查看某一个table表单的所有数据内容<br />\r\n&nbsp;&nbsp; &nbsp;select&nbsp;&nbsp; name,id&nbsp;&nbsp; from&nbsp;&nbsp; 表单&nbsp;&nbsp; where&nbsp; age=30;&nbsp;&nbsp; 查看某一个表单中年龄等于30岁的人的姓名和id号<br />\r\n&nbsp;&nbsp; &nbsp;双表查询，关键点：找到两个表都含有的关键字段<br />\r\n&nbsp;&nbsp; &nbsp;如：找到employee表中age是30岁的员工所属的dept_name<br />\r\n&nbsp;&nbsp; &nbsp;select&nbsp; dept_name from department&nbsp; where dept_id=(selet dept_id from employee where age=30);<br />\r\n&nbsp;<br />\r\n注意：题目如果有异议，可以切换语言到英文看英文题目。<br />\r\n<br />\r\n最后：<br />\r\n1、建议使用ssh登录，针对很多需要copy的内容<br />\r\n2、不要复制题目给的网址最后的.<br />\r\n3、全部题目只有20题，http考4题，脚本考1题，其他全部考<br />\r\n4、全部题目做完要在2.5小时左右，花1小时检查<br />\r\n5、检查的时候先重启server，server在ok之后再重启client，client重启要直接powroff然后再start，如果直接在client上reboot会一直卡着<br />\r\n6、检查的时候，按照题目顺序举逐个验证效果。<br />\r\n7、重点检查systemctl 是否enable相关服务还有firewall-cmd是否配置正确，建议：history | grep systemctl enable&nbsp;&nbsp; 和 histroty | grep firewall-cmd --permanet这种方式来查看你做过的配置命令确认哪些服务你是enable哪些服务你开通了防火墙，server和client都可以这样查<br />\r\n8、最后祝大家早日通过RHCE，证书只是一个目标，学习的过程才是我们最大的收获，完成RHCE只是一个起点，还有更多的技术和知识需要我们去学习，也希望大家可以多总结，多思考，沉淀更好的文档留存给后人学习和使用。<br />\r\n<br />\r\n<br />\r\n<br />\r\n<br />',1,0,0,1,3,'article_imgs/9.jpg',2),(10,'MPLS VPN疑难解析','2018-11-04 16:11:35.612348','2018-11-04 16:11:35.612348','1.export可以做多吗???????<br />\r\n可以有多个export的,只要import和export匹配就会学习,sh ip bgp vpn all看到的路由是已经经过RT的选择后的了<br />\r\n<br />\r\n2.本PE路由器为本私网路由打的私网标签是唯一的吗??????<br />\r\n是唯一的,即使PE上有相同的私网路由(从不同的VRF表得到),但是也会为他们分配不同的标签(1.1.1.1/32)<br />\r\n而且私网标签和公网标签也不会重复,它们是在一个标签表里的.<br />\r\n&nbsp;<br />\r\n<br />\r\n3.VPN之间不互通,这时候各个VPN的地址可以冲突<br />\r\n这时候虽然地址一样,但是每个VPN学习到的是自己VPN的地址,私网标签是不相同的.是通过私网标签来区分并发送到相应VPN的.<br />\r\n<br />\r\n4.VPN之间互通,而且地址还冲突(假设有两个172.16.1.1/32)<br />\r\n这时候一开始的那台PE还是正常工作,为这两个路由分配不同的私网标签.并且把这两条路由发送给对端PE路由器..(以下是关键)对端PE路由器上在同一个RD里收到了两条BGP路由,BGP会选出一条最优的,然后重分发到CE设备去.这时候CE设备去的172.16.1.1就是一个地方的了.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;<br />\r\n这里有一个问题:<br />\r\n按照正常的BGP,一台BGP路由器如果有两条相同的路由,那么只会发送一条最优的BGP路由给邻居,而这里,最初的PE路由器拥有两条相同目的的BGP路由,并没有选最优而是将这两条BGP路由都发送给对端PE,(按照正常情况,这里就应该选出最优的路由发送,猜想:这里这两条路由虽然目的地一样,但是所在的RD是不一样的,所以BGP当作是两条不同的路由发送,而不选最优),所以导致对端PE路由器收到两条BGP路由,而在对端路由器里,这两条相同目的地的BGP路由是在同一个RD里的,所以被认为是相同的路由,进而选出最优的路由.最后只把最优的路由重分发到CE设备<br />\r\n这里,对端的PE是如何选出最优的BGP路由的?<br />\r\n在把EIGRP重分发进BGP的时候会自动带上cost:pre-bestpath属性,pre-bestpath属性值就是EIGRP路由的花费<br />\r\n1.先选Cost:pre-bestpath小的,小的最优<br />\r\n2.再通过选路原则选最优<br />\r\n3.再通过其它扩展属性选出最优<br />\r\n总之一定能选出最优.<br />\r\n<br />\r\n5.RD的意义:(只在本PE路由器上有效)<br />\r\n(1).用于本地PE路由器,区分不同的VPN客户,同一个VPN客户的不同场点的RD可以不一样,但是建议一样,这样比较好管理<br />\r\n(2).用于结合ipv4前缀上使之变成vpn-ipv4路由,使之能被MP-BGP传递出去,(私网路由是不能被传递到公网的,但是如果变成了vpn的私网路由就可以通过MP-BGP传递出去了)<br />\r\n<br />\r\n6.如果VPN客户使用的是EBGP和PE相连接,那么PE上要在add-family ipv4 vrf vpn1 里做neibg ....&nbsp;&nbsp;&nbsp;&nbsp; 不需要做普通BGP的邻居.&nbsp;&nbsp; 路由也是自动传递(可使用策略来控制,策略在vpnv4邻居里做)<br />\r\n<br />\r\n7.如果PE和CE使用的是EBGP,而且VPN的多个场点都是同一个as的时候,对端CE会因为BGP路由里包含了本as号而不接收该路由(EBGP的水平分割).<br />\r\n通过在PE上使用命令:nei 1.1.1.1 as-overrid来取消水平分割(来支持as号码重叠)<br />\r\n<br />\r\n8.为什么PE路由器不对学自ip域内的路由做PHP的动作??????????????<br />\r\n对于学自ip域内的路由,一定是私网路由,对于私网路由要分配私网标签,如果为它们做PHP而不做私网标签的话,那么当有相同私网路由的时候,PE不知道该把数据包发往哪一个接口.不做PHP也对应为私网路由分配私网标签.<br />\r\n<br />\r\n<br />',1,0,0,1,5,'article_imgs/10.jpg',2),(11,'项目编写时的注意事项','2018-11-04 16:12:15.323409','2018-11-04 16:12:15.323409','<div class=\"post\">\r\n	<h1 class=\"postTitle\">\r\n		<a id=\"cb_post_title_url\" class=\"postTitle2\" href=\"https://www.cnblogs.com/zzzlw/p/9286862.html\">项目编写时的注意事项</a> \r\n	</h1>\r\n	<div class=\"clear\">\r\n	</div>\r\n	<div class=\"postBody\">\r\n		<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n			<p>\r\n				标签（空格分隔）： 个人总结\r\n			</p>\r\n			<hr />\r\n			<p>\r\n				最近学了很多知识点，也通过几个作业、项目将这些知识点串联在一起，相互协作完成一个程序丰富的功能。<br />\r\n在写项目的时候，最大的困难是没有一个很好的编写流程。虽然对于项目的每一个功能都可以单独的分析并提出解决方法和思路，也可以写出对应的知识点来完成此功能。但是多个功能之间的交互、函数划分、接口调用方法等等，涉及模块之间或者说涉及全局规划时，就会无从下手。\r\n			</p>\r\n			<p>\r\n				自己分析过，可能有几个原因：\r\n			</p>\r\n<pre>1、看的其他人写的代码太少，其他人写的架构、思路是可以借鉴的\r\n2、自己写的代码太少，（不过在没有架构思维的情况下一味的练习只会转牛角尖出不来）\r\n3、需要一个全流程的指导，并分析各个环节的作用，环节之间的相互作用</pre>\r\n			<hr />\r\n			<p>\r\n				经过1个多月的学习，从自己的代码、别人写的代码、一些书籍的阅读之后，大致对于全局编码，有如下几点经验：\r\n			</p>\r\n<pre>设计角度： <span class=\"hljs-number\">1</span>、函数大小：不应该超过<span class=\"hljs-number\">1</span>页 <span class=\"hljs-number\">2</span>、高聚合：一个函数里的代码应该有一个共同完成的目标，如果有两个，应该拆分 <span class=\"hljs-number\">3</span>、耦合性：\r\n    a、使用参数和<span class=\"hljs-keyword\">return</span>来提高耦合，尽量甚至不使用全局变量\r\n    b、避免修改传入的对象内容，如果有必要，可以考虑copy <span class=\"hljs-built_in\">c</span>、避免<span class=\"hljs-keyword\">import</span> *，一是可读性差，二是污染当前模块命名空间\r\n    d、函数接口设计要功能分离，同时，将系统函数（或常用函数）与自定义函数分开，方便后期测试</pre>\r\n			<hr />\r\n<pre>类角度：\r\n1、类的接口，哪些需要对外提供，哪些是内部接口（使用 _ 或者 __ 来隐藏接口）\r\n2、类中方法的抽象层次，一般来说，相似的功能应该有相同的抽象层次，抽象层次的设计就是函数结构的设计\r\n3、函数的通用性，函数应该尽量设计成可以通用的，这样可以提高抽象程度</pre>\r\n			<hr />\r\n<pre>编码角度：\r\n1、每次应该只写一小部分代码，聚焦一个小功能的实现，不要这里写一点，那里修改一点，聚焦视角\r\n2、每完成一小部分代码的编写，立马测试\r\n3、小步走，多测试\r\n4、要有框架思维、全局思路，但是实际编码的时候应该一步步写，日渐丰富程序功能。一开始就写好框架再填写代码并不合适（至少目前对我而言），非常容易发生：写到某一部分时发现需要重构框架，导致整体推翻。\r\n5、内部接口和外部接口一样要整洁漂亮，内部接口代码（对内使用）不应该随意编写。</pre>\r\n			<hr />\r\n<pre>几点教训：\r\n1、不应该过于抽象化，因为抽象化意味着高耦合，一旦需要重构，需要修改每一处被抽象的地方。\r\n2、不应该过长时间思考和编码，如果连续编码8个小时，基本上已经没有思路和创新，应该休息和放松。\r\n3、精力很重要，所以要经常锻炼身体，我发现身体的锻炼可以提升脑力容量。\r\n4、编码的速度越快、一次性想要做的事情越多，就会做的越差，慢即是快，真的是一个矛盾但是有效的事实。</pre>\r\n		</div>\r\n		<div id=\"MySignature\">\r\n		</div>\r\n		<div class=\"clear\">\r\n		</div>\r\n		<div id=\"blog_post_info_block\">\r\n			<div id=\"BlogPostCategory\">\r\n				<br />\r\n			</div>\r\n		</div>\r\n	</div>\r\n</div>',1,0,0,1,4,'article_imgs/11.jpg',7);
/*!40000 ALTER TABLE `blog_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_articleupdown`
--

DROP TABLE IF EXISTS `blog_articleupdown`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_articleupdown` (
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `is_like` tinyint(1) DEFAULT NULL,
  `article_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`nid`),
  KEY `blog_articleupdown_article_id_9be1a8a2_fk_blog_article_nid` (`article_id`),
  KEY `blog_articleupdown_user_id_2c0ebe49_fk_blog_account_nid` (`user_id`),
  CONSTRAINT `blog_articleupdown_article_id_9be1a8a2_fk_blog_article_nid` FOREIGN KEY (`article_id`) REFERENCES `blog_article` (`nid`),
  CONSTRAINT `blog_articleupdown_user_id_2c0ebe49_fk_blog_account_nid` FOREIGN KEY (`user_id`) REFERENCES `blog_account` (`nid`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_articleupdown`
--

LOCK TABLES `blog_articleupdown` WRITE;
/*!40000 ALTER TABLE `blog_articleupdown` DISABLE KEYS */;
INSERT INTO `blog_articleupdown` VALUES (1,1,1,2),(2,1,1,4);
/*!40000 ALTER TABLE `blog_articleupdown` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_blog`
--

DROP TABLE IF EXISTS `blog_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_blog` (
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `path` varchar(16) NOT NULL,
  `theme` varchar(16) NOT NULL,
  `create_time` datetime(6) NOT NULL,
  `article_count` int(11) NOT NULL,
  `category_count` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`nid`),
  UNIQUE KEY `path` (`path`),
  UNIQUE KEY `user_id` (`user_id`),
  CONSTRAINT `blog_blog_user_id_0e1a17e5_fk_blog_account_nid` FOREIGN KEY (`user_id`) REFERENCES `blog_account` (`nid`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_blog`
--

LOCK TABLES `blog_blog` WRITE;
/*!40000 ALTER TABLE `blog_blog` DISABLE KEYS */;
INSERT INTO `blog_blog` VALUES (1,'zlw10100','','2018-11-04 13:04:58.953937',0,0,1),(2,'zouliwei','','2018-11-04 16:22:52.957998',0,0,2),(3,'wj123','','2018-11-04 16:25:57.311616',0,0,3),(4,'zhiqiang','','2018-11-04 16:44:34.287690',0,0,4);
/*!40000 ALTER TABLE `blog_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_category`
--

DROP TABLE IF EXISTS `blog_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_category` (
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(16) NOT NULL,
  `article_count` int(11) NOT NULL,
  `blog_id` int(11) NOT NULL,
  PRIMARY KEY (`nid`),
  KEY `blog_category_blog_id_80f0723a_fk_blog_blog_nid` (`blog_id`),
  CONSTRAINT `blog_category_blog_id_80f0723a_fk_blog_blog_nid` FOREIGN KEY (`blog_id`) REFERENCES `blog_blog` (`nid`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_category`
--

LOCK TABLES `blog_category` WRITE;
/*!40000 ALTER TABLE `blog_category` DISABLE KEYS */;
INSERT INTO `blog_category` VALUES (1,'Python',2,1),(2,'Django',3,1),(3,'Linux',1,1),(4,'编程',1,1),(5,'路由交换',1,1),(6,'JavaScript',2,1);
/*!40000 ALTER TABLE `blog_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_comment`
--

DROP TABLE IF EXISTS `blog_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_comment` (
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `content` longtext NOT NULL,
  `article_id` int(11) NOT NULL,
  `parent_id` int(11) DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  `created_at` datetime(6) NOT NULL,
  `reply_to` varchar(16) DEFAULT NULL,
  `root_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`nid`),
  KEY `blog_comment_article_id_3d58bca6_fk_blog_article_nid` (`article_id`),
  KEY `blog_comment_user_id_59a54155_fk_blog_account_nid` (`user_id`),
  KEY `blog_comment_parent_id_f2a027bb_fk_blog_comment_nid` (`parent_id`),
  CONSTRAINT `blog_comment_article_id_3d58bca6_fk_blog_article_nid` FOREIGN KEY (`article_id`) REFERENCES `blog_article` (`nid`),
  CONSTRAINT `blog_comment_parent_id_f2a027bb_fk_blog_comment_nid` FOREIGN KEY (`parent_id`) REFERENCES `blog_comment` (`nid`),
  CONSTRAINT `blog_comment_user_id_59a54155_fk_blog_account_nid` FOREIGN KEY (`user_id`) REFERENCES `blog_account` (`nid`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_comment`
--

LOCK TABLES `blog_comment` WRITE;
/*!40000 ALTER TABLE `blog_comment` DISABLE KEYS */;
INSERT INTO `blog_comment` VALUES (1,'写的很好，支持一下，希望博主可以尽快更新，加油！',1,NULL,2,'2018-11-04 16:23:48.828739',NULL,NULL),(2,'那时候聊天还喜欢用呵呵，还喜欢装扮自己的空间，喜欢好友买卖，抢车位，在空间留言板聊天，现在那些人，都不见了，我也要结婚了',1,NULL,2,'2018-11-04 16:24:16.996635',NULL,NULL),(3,'那时候聊天还喜欢用呵呵，还喜欢装扮自己的空间，喜欢好友买卖，抢车位，在空间留言板聊天，现在那些人，都不见了，我也要结婚了',3,NULL,2,'2018-11-04 16:24:20.894654',NULL,NULL),(4,'那时候聊天还喜欢用呵呵，还喜欢装扮自己的空间，喜欢好友买卖，抢车位，在空间留言板聊天，现在那些人，都不见了，我也要结婚了',4,NULL,2,'2018-11-04 16:24:23.928275',NULL,NULL),(5,'那时候聊天还喜欢用呵呵，还喜欢装扮自己的空间，喜欢好友买卖，抢车位，在空间留言板聊天，现在那些人，都不见了，我也要结婚了',7,NULL,2,'2018-11-04 16:24:27.934682',NULL,NULL),(6,'那时候聊天还喜欢用呵呵，还喜欢装扮自己的空间，喜欢好友买卖，抢车位，在空间留言板聊天，现在那些人，都不见了，我也要结婚了',8,NULL,2,'2018-11-04 16:24:31.756102',NULL,NULL),(7,'那时候聊天还喜欢用呵呵，还喜欢装扮自己的空间，喜欢好友买卖，抢车位，在空间留言板聊天，现在那些人，都不见了，我也要结婚了',9,NULL,2,'2018-11-04 16:24:39.014086',NULL,NULL),(8,'没人觉的歌词其实很美吗！ 。。。。。。。。 “春恋柳妩媚，蝶恋花香味，长依偎。只要你完美我情愿破碎，无所谓。因你阴晴圆缺而喜悲”',11,NULL,2,'2018-11-04 16:24:47.436275',NULL,NULL),(9,'中央电视台有一个叫 同一首歌 的节目 花儿出来的时候整个人都要跳起来了 看到大张伟跳的都是汗 气息还是很稳 在学校小卖部的电视买零食是刚好看到大张伟出现唱歌 开心的不得了 突然听到小卖部的老板娘说 我最讨厌花儿瞎蹦什么 自此 再没去过那个小卖部 剩下好多零花钱',10,NULL,2,'2018-11-04 16:24:57.164467',NULL,NULL),(10,'有的人应该在神坛，可他一直跑到人群里当小丑，手舞足蹈，只为博君一笑。有的人平平无奇，但是被捧高到神坛，众人仰望，然而一摔跤，比小丑还狼狈。我们的小丑——我们深爱的大张伟，祝你平安喜乐，长命百岁。',5,NULL,2,'2018-11-04 16:25:04.378762',NULL,NULL),(11,'当你说出这句话的时候，我就知道没有必要与你再争论，因为要跟一个毫无了解的人辩论，实在是没必要',6,NULL,2,'2018-11-04 16:25:11.796729',NULL,NULL),(12,'求佛 秋天不回来 香水有毒 香烟爱上火柴 冲动的惩罚 那一夜 一个深爱的女孩 亲爱的我们究竟怎么了 狗尾草 回心转意 难以启齿的柔弱 分开不一定分手 我们的无奈 如果爱能早些说出来 得到你的人却得不到你的心 愚爱 心痛2009 不要再来伤害我 你到底爱谁 不怕不怕 该死的温柔 只想做你的男人 别赞要脸',1,NULL,3,'2018-11-04 16:27:03.905746',NULL,NULL),(13,'他歌手时是CCTV的常客，很多CCTV晚会他都去唱歌我粉上他时已经是演员的身份了，看他过去的经历才知道那么精彩',1,1,3,'2018-11-04 16:27:13.121270','zouliwei',1),(14,'过了好久在来听这首歌又回忆起以前迷恋马天宇的青春期了，这首歌还是一如既往的好听',1,2,3,'2018-11-04 16:27:24.059220','zouliwei',2),(15,'讲一个励志的故事吧，十年前，有一个人为了创业把北京的房子卖了，拿着50万房款开始创业，十年后，他拿着创业赚来的400万在北京交了套首付。',1,13,2,'2018-11-04 16:27:59.396317','wj123',1),(16,'学生时代同桌是位女生，被班主任叫到办公室问我喜不喜欢同桌，我否认了，回到教室发现她已经搬到前面了，我笑了笑说 你怎么不和我坐一起了啊，她没说话用黑色眸子看着我笑了笑，只不过她那发红的眼睛是藏不住的，各奔东西后才明白她眼睛是为了谁红。新婚快乐，让我喜欢你最后一次',1,NULL,2,'2018-11-04 16:28:08.477495',NULL,NULL),(17,'玫瑰花的葬礼 2：犯jiàn 3：红妆 4：老人与海 5：别在我离开之前离开（还有泰语版 即使知道要见面） 6：飞向别人的床 7：后会无期 8：该死的温柔（emmmm....看评论想到的差点没听出来hhhh） 9：素颜 10：步步高音乐手机名字叫啥忘了反正冯曦妤唱过！ 11：绝对听过实在没想起来名字QAQ 12：樱花草',1,14,2,'2018-11-04 16:28:17.474978','wj123',2),(18,'抄袭了hall of fame,但也重新了进行了编曲,有自己的特色,里面融合了沧桑沙哑的成熟男声和稚嫩小男生的嗲嗲声,有创新.我是先听到这首歌,后听hall of fame.这首歌给我的激励比原作更多.听感更好',1,15,1,'2018-11-04 16:28:44.340077','zouliwei',1),(19,'没人知道高三时的我压力有多大，单招失利，要完全靠三个月的时间补习二百多分的文化课，跟最好的闺密冷战，高考前两个月父母要离婚，在学校在家真的没有一个地方能让我喘一口气。谁知道自己半夜在没有灯的操场上默默流泪的滋味。当时我就听着这首歌，一遍遍告诉自己，我能挺过去。',1,13,1,'2018-11-04 16:28:49.752985','wj123',1),(20,'高中时一个同学沉迷网络，时常半夜翻墙出校上网。一日他照例翻墙，翻到一半就拔足狂奔而归，面色古怪，问之不语。从此认真读书，不在上网，学校盛传他见了鬼了。后来他考上了名校，后来我们问到这事，他沉默良久说，那天他父亲送来生活费，舍不得住旅馆，在墙下坐了一夜。 2016年8月16日 21:27回复|分享|(62668)举报|  斯莱特林再加十分:',1,NULL,1,'2018-11-04 16:28:56.339052',NULL,NULL),(21,'刚在宿舍看书学习，隔壁宿舍来了一个人过来问有没有报纸，我们同寝的那个舍友就阴阳怪气的讽刺说：你快别说话了，人家在学习呢，别打扰人家，人家跟咱们可不一样，人家可是要考公务员的呦～ 其实我也是很不明白那些混吃等死的还看不惯别人努力是怎么个心态 还是有梦想会努力的好 不做混吃等死的废人。',1,13,1,'2018-11-04 16:29:02.381976','wj123',1),(22,'6666666666',1,20,2,'2018-11-04 16:43:22.781376','zlw10100',20),(23,'6666666欢迎来到暴雪上海公司',1,21,4,'2018-11-04 16:46:26.476803','zlw10100',1);
/*!40000 ALTER TABLE `blog_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_profile`
--

DROP TABLE IF EXISTS `blog_profile`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_profile` (
  `nid` int(11) NOT NULL AUTO_INCREMENT,
  `city` varchar(32) DEFAULT NULL,
  `introduction` longtext,
  `college` varchar(32) DEFAULT NULL,
  `company` varchar(64) DEFAULT NULL,
  `title` varchar(64) DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  `avatar` varchar(100) NOT NULL,
  `nick_name` varchar(16),
  PRIMARY KEY (`nid`),
  UNIQUE KEY `user_id` (`user_id`),
  CONSTRAINT `blog_profile_user_id_2bc46caa_fk_blog_account_nid` FOREIGN KEY (`user_id`) REFERENCES `blog_account` (`nid`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_profile`
--

LOCK TABLES `blog_profile` WRITE;
/*!40000 ALTER TABLE `blog_profile` DISABLE KEYS */;
INSERT INTO `blog_profile` VALUES (1,'杭州','未知个人信息','无','无','无',1,'avatars/zlw10100.jpg','一人之下张楚岚'),(2,'未知城市','未知个人信息','无','无','无',2,'avatars/zouliwei.jpg','镇魂将曹焱兵'),(3,'未知城市','未知个人信息','无','无','无',3,'avatars/wj123.jpg','不长痘痘的汪汪'),(4,'未知城市','未知个人信息','无','无','无',4,'avatars/default_female.png','暴雪工程师');
/*!40000 ALTER TABLE `blog_profile` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_admin_log`
--

DROP TABLE IF EXISTS `django_admin_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_admin_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `action_time` datetime(6) NOT NULL,
  `object_id` longtext,
  `object_repr` varchar(200) NOT NULL,
  `action_flag` smallint(5) unsigned NOT NULL,
  `change_message` longtext NOT NULL,
  `content_type_id` int(11) DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `django_admin_log_content_type_id_c4bce8eb_fk_django_co` (`content_type_id`),
  KEY `django_admin_log_user_id_c564eba6_fk_blog_account_nid` (`user_id`),
  CONSTRAINT `django_admin_log_content_type_id_c4bce8eb_fk_django_co` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`),
  CONSTRAINT `django_admin_log_user_id_c564eba6_fk_blog_account_nid` FOREIGN KEY (`user_id`) REFERENCES `blog_account` (`nid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_admin_log`
--

LOCK TABLES `django_admin_log` WRITE;
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_content_type`
--

DROP TABLE IF EXISTS `django_content_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_content_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_label` varchar(100) NOT NULL,
  `model` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `django_content_type_app_label_model_76bd3d3b_uniq` (`app_label`,`model`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_content_type`
--

LOCK TABLES `django_content_type` WRITE;
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` VALUES (1,'admin','logentry'),(3,'auth','group'),(2,'auth','permission'),(6,'blog','account'),(7,'blog','article'),(8,'blog','articleupdown'),(9,'blog','blog'),(10,'blog','category'),(11,'blog','comment'),(12,'blog','profile'),(4,'contenttypes','contenttype'),(5,'sessions','session');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_migrations`
--

DROP TABLE IF EXISTS `django_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_migrations` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `applied` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_migrations`
--

LOCK TABLES `django_migrations` WRITE;
/*!40000 ALTER TABLE `django_migrations` DISABLE KEYS */;
INSERT INTO `django_migrations` VALUES (1,'contenttypes','0001_initial','2018-11-04 13:01:23.538229'),(2,'contenttypes','0002_remove_content_type_name','2018-11-04 13:01:23.767863'),(3,'auth','0001_initial','2018-11-04 13:01:24.425970'),(4,'auth','0002_alter_permission_name_max_length','2018-11-04 13:01:24.615463'),(5,'auth','0003_alter_user_email_max_length','2018-11-04 13:01:24.625471'),(6,'auth','0004_alter_user_username_opts','2018-11-04 13:01:24.636408'),(7,'auth','0005_alter_user_last_login_null','2018-11-04 13:01:24.646380'),(8,'auth','0006_require_contenttypes_0002','2018-11-04 13:01:24.653388'),(9,'auth','0007_alter_validators_add_error_messages','2018-11-04 13:01:24.662365'),(10,'auth','0008_alter_user_username_max_length','2018-11-04 13:01:24.672338'),(11,'auth','0009_alter_user_last_name_max_length','2018-11-04 13:01:24.683282'),(12,'blog','0001_initial','2018-11-04 13:01:29.066206'),(13,'admin','0001_initial','2018-11-04 13:01:30.083479'),(14,'admin','0002_logentry_remove_auto_add','2018-11-04 13:01:30.099437'),(15,'admin','0003_logentry_add_action_flag_choices','2018-11-04 13:01:30.118359'),(16,'blog','0002_auto_20181104_1301','2018-11-04 13:01:32.156729'),(17,'sessions','0001_initial','2018-11-04 13:01:32.314070');
/*!40000 ALTER TABLE `django_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_session`
--

DROP TABLE IF EXISTS `django_session`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_session` (
  `session_key` varchar(40) NOT NULL,
  `session_data` longtext NOT NULL,
  `expire_date` datetime(6) NOT NULL,
  PRIMARY KEY (`session_key`),
  KEY `django_session_expire_date_a5c62663` (`expire_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_session`
--

LOCK TABLES `django_session` WRITE;
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` VALUES ('0ap0v6ulyikkzoya6vkqq3ou4cygijjg','MjU0NTQ2MDY1NWIwODYyMWNlOTI3MzY4Njc5NDg2NGJlOTcwMDQwNTp7InZhbGlkYXRlX2NvZGUiOiJIRWFtVyIsIl9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJiYzk2OGJmMGFmMDdjMTljOWRiMmQwOTlhMjMzNDllYmUxNTllMGVmIn0=','2018-11-18 16:28:27.888458'),('1i7jiquwe786nh8d8zoujru6df9nxgvb','MjNiNGE4NzE3ZGJhZGJmMzQ3Nzg1NjgzMTczOGEzNDc1NTM0MzYwOTp7InZhbGlkYXRlX2NvZGUiOiJ1eXRIVSJ9','2018-11-18 16:46:32.886564'),('36lpqe0hbvzlba6sb4p5o7bwvt410ec4','MmEwZGNhMzAwNjVjNGI1YzY4MzVhZjlmMWRmODE3N2ZmNzdhZDYzYjp7InZhbGlkYXRlX2NvZGUiOiI2d2lscyJ9','2018-11-18 16:47:22.309010'),('9j5079ex4oyqvap55qbqy0z2ugekvslm','MTNkNzU0MTZkNzg4ODU0MzU5ZTE4ZjIzZGJlYWFjZWMzMjM0ZDgxMTp7InZhbGlkYXRlX2NvZGUiOiJCd3ZuYSJ9','2018-11-18 16:43:34.000565'),('crth6ndnh9z7g1frla14ugb7waf51pjb','NjhhZjM3ZGYzMDY1ZDE0ZmI2ZDkxOTZhYTQ3MGYxOTgxNWQ4NDU1ZTp7InZhbGlkYXRlX2NvZGUiOiJPYlRYWCJ9','2018-11-18 16:56:01.561510');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;


